{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/index","pixi-spine.min.js","src/SpineRuntime/Animation.js","src/SpineRuntime/AnimationState.js","src/SpineRuntime/AnimationStateData.js","src/SpineRuntime/Atlas.js","src/SpineRuntime/AtlasAttachmentParser.js","src/SpineRuntime/AtlasPage.js","src/SpineRuntime/AtlasReader.js","src/SpineRuntime/AtlasRegion.js","src/SpineRuntime/AttachmentTimeline.js","src/SpineRuntime/AttachmentType.js","src/SpineRuntime/Bone.js","src/SpineRuntime/BoneData.js","src/SpineRuntime/BoundingBoxAttachment.js","src/SpineRuntime/ColorTimeline.js","src/SpineRuntime/Curves.js","src/SpineRuntime/DrawOrderTimeline.js","src/SpineRuntime/Event.js","src/SpineRuntime/EventData.js","src/SpineRuntime/EventTimeline.js","src/SpineRuntime/FfdTimeline.js","src/SpineRuntime/IkConstraint.js","src/SpineRuntime/IkConstraintData.js","src/SpineRuntime/IkConstraintTimeline.js","src/SpineRuntime/MeshAttachment.js","src/SpineRuntime/RegionAttachment.js","src/SpineRuntime/RotateTimeline.js","src/SpineRuntime/ScaleTimeline.js","src/SpineRuntime/ShearTimeline.js","src/SpineRuntime/Skeleton.js","src/SpineRuntime/SkeletonBounds.js","src/SpineRuntime/SkeletonData.js","src/SpineRuntime/SkeletonJsonParser.js","src/SpineRuntime/Skin.js","src/SpineRuntime/Slot.js","src/SpineRuntime/SlotData.js","src/SpineRuntime/TrackEntry.js","src/SpineRuntime/TransformConstraint.js","src/SpineRuntime/TransformConstraintData.js","src/SpineRuntime/TransformConstraintTimeline.js","src/SpineRuntime/TranslateTimeline.js","src/SpineRuntime/WeightedMeshAttachment.js","src/SpineRuntime/index.js","src/SpineUtil/index.js","src/Spine/index.js","src/loaders/Loader.js","src/loaders/atlasParser.js","src/loaders/imageLoaderAdapter.js","src/loaders/index.js","src/loaders/syncImageLoaderAdapter.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","PIXI","spine","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","Spine","SpineRuntime","loaders","./Spine","./SpineRuntime","./loaders","2","Animation","name","timelines","duration","prototype","apply","skeleton","lastTime","time","loop","events","mix","alpha","binarySearch","values","target","step","low","high","Math","floor","current","binarySearch1","linearSearch","last","../SpineUtil","3","TrackEntry","AnimationState","stateData","data","tracks","onStart","onEnd","onComplete","onEvent","timeScale","update","delta","previous","previousDelta","mixTime","next","delay","setCurrent","endTime","clearTrack","resetDrawOrder","previousTime","animation","mixDuration","ii","nn","event","count","clearTracks","trackIndex","_expandToIndex","index","push","entry","getMix","setAnimationByName","animationName","skeletonData","findAnimation","setAnimation","addAnimationByName","addAnimation","hasAnimationByName","getCurrent","./TrackEntry","4","AnimationStateData","animationToMixTime","defaultMix","setMixByName","fromName","toName","from","to","setMix","key","hasOwnProperty","5","AtlasReader","AtlasPage","AtlasRegion","syncImageLoaderAdapter","Atlas","atlasText","loaderFunction","callback","pages","regions","addSpineAtlas","addTexture","texture","page","rendererObject","baseTexture","width","realWidth","height","realHeight","format","minFilter","magFilter","uWrap","TextureWrap","clampToEdge","vWrap","region","addTextureHash","textures","stripExtension","indexOf","substr","lastIndexOf","iterateParser","line","reader","readLine","trim","readTuple","tuple","parseInt","Format","TextureFilter","direction","readValue","repeat","hasLoaded","console","log","rotate","x","y","resolution","frame","Rectangle","splits","pads","originalWidth","originalHeight","offsetX","offsetY","orig","VERSION","Texture","frame2","crop","clone","_updateUvs","baseUrl","crossOrigin","texturesLoading","findRegion","dispose","destroy","updateUVs","intensity","luminanceAlpha","rgb565","rgba4444","rgb888","rgba8888","nearest","linear","mipMap","mipMapNearestNearest","mipMapLinearNearest","mipMapNearestLinear","mipMapLinearLinear","mirroredRepeat","../loaders/syncImageLoaderAdapter.js","./AtlasPage","./AtlasReader","./AtlasRegion","6","RegionAttachment","MeshAttachment","WeightedMeshAttachment","BoundingBoxAttachment","AtlasAttachmentParser","atlas","newRegionAttachment","skin","path","attachment","setUVs","v","u2","v2","regionOffsetX","regionOffsetY","spineOffsetY","regionWidth","regionHeight","regionOriginalWidth","regionOriginalHeight","newMeshAttachment","newWeightedMeshAttachment","newBoundingBoxAttachment","./BoundingBoxAttachment","./MeshAttachment","./RegionAttachment","./WeightedMeshAttachment","7","8","text","lines","split","value","replace","colon","substring","lastMatch","comma","9","Object","defineProperties","get","tex","_uvs","x0","y0","x2","y2","warn","pixiOffsetY","10","Curves","AttachmentTimeline","frameCount","curves","frames","attachmentNames","slotIndex","getFrameCount","setFrame","frameIndex","attachmentName","firedEvents","Number","MAX_VALUE","slots","setAttachment","getAttachmentBySlotIndex","./Animation","./Curves","11","AttachmentType","boundingbox","mesh","weightedmesh","skinnedmesh","linkedmesh","weightedlinkedmesh","12","Bone","boneData","parent","matrix","Matrix","setToSetupPose","yDown","rotation","rotationIK","scaleX","scaleY","shearX","shearY","flipX","flipY","worldSignX","worldSignY","updateWorldTransform","rotationX","rotationY","la","cos","degRad","lb","lc","sin","ld","m","c","b","d","tx","ty","signum","pa","pb","pc","pd","inheritRotation","inheritScale","temp","psx","psy","za","zb","zc","zd","worldToLocal","world","dx","dy","invDet","localToWorld","local","localX","localY","getWorldRotationX","atan2","radDeg","getWorldRotationY","getWorldScaleX","sqrt","getWorldScaleY","worldX","worldY","13","BoneData","14","vertices","type","computeWorldVertices","bone","worldVertices","m00","m01","m10","m11","px","py","./AttachmentType","15","ColorTimeline","prevFrameR","prevFrameG","prevFrameB","prevFrameA","frameTime","percent","getCurvePercent","slot","16","setLinear","setStepped","setCurve","cx1","cy1","cx2","cy2","subdiv1","subdiv2","subdiv3","pre1","pre2","pre4","pre5","tmp1x","tmp1y","tmp2x","tmp2y","dfx","dfy","ddfx","ddfy","dddfx","dddfy","start","prevX","prevY","17","DrawOrderTimeline","drawOrders","drawOrder","drawOrderToSetupIndex","18","Event","intValue","floatValue","stringValue","19","EventData","20","EventTimeline","21","FfdTimeline","frameVertices","slotAttachment","applyFFD","vertexCount","attachmentVertices","k","lastVertices","prevVertices","nextVertices","prev","22","IkConstraint","bendDirection","bones","findBone","apply1","apply2","targetX","targetY","parentRotation","child","bendDir","offset1","offset2","sign2","csx","cy","pp","ppm","wx","wy","a1","a2","l1","l2","outer","abs","acos","ta","aa","bb","ll","dd","c0","c1","c2","q","r0","r1","minAngle","minDist","Infinity","minX","minY","maxAngle","maxDist","maxX","maxY","dist","PI","angle","offset","23","IkConstraintData","24","IkConstraintTimeline","ikConstraintIndex","ikConstraint","ikConstraints","prevFrameMix","25","parentMesh","inheritFFD","uvs","regionUVs","triangles","hullLength","edges","Float32Array","w1","h1","w2","h2","x1","x3","y1","y3","verticesCount","vx","vy","sourceAttachment","setParentMesh","hackRegion","newRegion","oldRegion","26","updateOffset","regionScaleX","regionScaleY","localX2","localY2","radians","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","computeVertices","size","27","RotateTimeline","boneIndex","amount","prevFrameValue","28","ScaleTimeline","prevFrameX","prevFrameY","29","ShearTimeline","30","Slot","Skeleton","slotData","transformConstraints","TransformConstraint","boneCache","updateCache","ikConstraintsCount","transformConstraintsCount","j","setBonesToSetupPose","setSlotsToSetupPose","constraint","rotateMix","translateMix","scaleMix","shearMix","getRootBone","boneName","findBoneIndex","findSlot","slotName","findSlotIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","_attachAll","getAttachment","getAttachmentBySlotName","defaultSkin","findIkConstraint","constraintName","constraints","findTransformConstraint","./Bone","./IkConstraint","./Slot","31","SkeletonBounds","polygonPool","polygons","boundingBoxes","updateAabb","slotCount","boundingBox","polygon","poolCount","splice","aabbCompute","MIN_VALUE","min","max","aabbContainsPoint","aabbIntersectsSegment","aabbIntersectsSkeleton","bounds","containsPoint","polygonContainsPoint","intersectsSegment","prevIndex","inside","vertexY","vertexX","polygonIntersectsSegment","width12","height12","det1","x4","y4","det2","width34","height34","det3","getPolygon","getWidth","getHeight","../SpineRuntime","32","SkeletonData","skins","animations","version","hash","findEvent","eventName","33","LinkedMesh","TransformConstraintData","SlotData","Skin","TranslateTimeline","TransformConstraintTimeline","SkeletonJsonParser","attachmentLoader","AtlasAttachmentLoader","linkedMeshes","scale","readSkeletonData","root","skeletonMap","boneMap","ik","ikMap","ikConstraintData","transform","transformMap","transformData","offsetRotation","offsetScaleX","offsetScaleY","offsetShearY","slotMap","color","toColor","blendMode","PIXI_BLEND_MODE_MAP","skinMap","slotEntry","readAttachment","addAttachment","linkedMesh","eventMap","eventData","readAnimation","map","getFloatArray","getIntArray","weights","boneCount","timelineName","timeline","valueMap","readCurve","timelineScale","ikConstraintName","transformConstraintName","transformConstraint","transformConstraintIndex","ffd","meshMap","meshName","isMesh","verticesValue","meshVertices","drawOrderValues","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","curve","Array","hexString","colorIndex","list","Uint16Array","./AttachmentTimeline","./BoneData","./ColorTimeline","./DrawOrderTimeline","./Event","./EventData","./EventTimeline","./FfdTimeline","./IkConstraintData","./IkConstraintTimeline","./RotateTimeline","./ScaleTimeline","./ShearTimeline","./SkeletonData","./Skin","./SlotData","./TransformConstraintData","./TransformConstraintTimeline","./TranslateTimeline","34","attachments","oldSkin","35","_attachmentTime","setAttachmentTime","getAttachmentTime","slotDatas","36","multiply","BLEND_MODES","MULTIPLY","screen","SCREEN","additive","ADD","normal","NORMAL","37","38","tempVec","bm","tm","bs","ts","by","39","40","shareMix","translate","shear","41","42","regionU2","regionU","regionV2","regionV","weight","skeletonBones","w","43","./AnimationState","./AnimationStateData","./Atlas","./AtlasAttachmentParser","./Skeleton","./SkeletonBounds","./SkeletonJsonParser","./Skin.js","./TransformConstraint","44","45","spineData","Container","state","slotContainers","slotContainer","addChild","spriteName","sprite","createSprite","currentSprite","currentSpriteName","createMesh","currentMesh","currentMeshName","autoUpdate","tintRgb","SlotContainerUpdateTransformV3","pt","worldTransform","wt","lt","localTransform","worldAlpha","_currentBounds","atlasParser","TransformBase","TransformManual","fromAtlas","resourceName","AnimCache","create","constructor","globalAutoUpdate","updateTransform","autoUpdateTransform","set","tint","utils","rgb2hex","hex2rgb","tempRgb","dt","children","g0","b0","undefined","visible","sprites","matrix2d","_dirtyVersion","isStatic","operMode","position","_dirtyLocal","TransformStatic","_dirtyParentVersion","_versionLocal","copy","displayObjectUpdateTransform","meshes","dirty","Date","now","timeDelta","descriptor","Sprite","anchor","strip","Mesh","DRAW_MODES","TRIANGLES","canvasPadding","hackTextureBySlotIndex","indexDirty","hackTextureBySlotName","../loaders/atlasParser","46","Loader","addPixiMiddleware","loader","use","./atlasParser","47","Resource","imageLoaderAdapter","resource","isJson","metadataAtlas","metadata","spineAtlas","spineJsonParser","enableCaching","metadataAtlasSuffix","spineAtlasSuffix","atlasPath","url","atlasOptions","xhrType","XHR_RESPONSE_TYPE","TEXT","spineMetadata","imageOptions","imageMetadata","adapter","add","res","xhr","responseText","./imageLoaderAdapter","48","namePrefix","49","./Loader","./syncImageLoaderAdapter","50","BaseTexture","fromImage"],"mappings":"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","file":"pixi-spine.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\r\n * @namespace PIXI.spine\r\n */\r\nmodule.exports = PIXI.spine = { // \"PIXI.spine\" assignment is here for people/plugins who use plugin both through require and as a plugin.\r\n    Spine:          require('./Spine'),\r\n    SpineRuntime:   require('./SpineRuntime'),\r\n    loaders:        require('./loaders')\r\n};\r\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}(g.PIXI || (g.PIXI = {})).spine = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\r\n * @namespace PIXI.spine\r\n */\r\nmodule.exports = PIXI.spine = { // \"PIXI.spine\" assignment is here for people/plugins who use plugin both through require and as a plugin.\r\n    Spine:          require('./Spine'),\r\n    SpineRuntime:   require('./SpineRuntime'),\r\n    loaders:        require('./loaders')\r\n};\r\n\n},{\"./Spine\":45,\"./SpineRuntime\":43,\"./loaders\":49}],2:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = function (name, timelines, duration)\r\n{\r\n    this.name = name;\r\n    this.timelines = timelines;\r\n    this.duration = duration;\r\n};\r\nspine.Animation.prototype = {\r\n    apply: function (skeleton, lastTime, time, loop, events)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\r\n    },\r\n    mix: function (skeleton, lastTime, time, loop, events, alpha)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\r\n    }\r\n};\r\nspine.Animation.binarySearch = function (values, target, step)\r\n{\r\n    var low = 0;\r\n    var high = Math.floor(values.length / step) - 2;\r\n    if (!high) return step;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[(current + 1) * step] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return (low + 1) * step;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.binarySearch1 = function (values, target)\r\n{\r\n    var low = 0;\r\n    var high = values.length - 2;\r\n    if (!high) return 1;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[current + 1] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return low + 1;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.linearSearch = function (values, target, step)\r\n{\r\n    for (var i = 0, last = values.length - step; i <= last; i += step)\r\n        if (values[i] > target) return i;\r\n    return -1;\r\n};\r\nmodule.exports = spine.Animation;\r\n\n},{\"../SpineUtil\":44}],3:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.TrackEntry = require('./TrackEntry');\r\nspine.AnimationState = function (stateData)\r\n{\r\n    this.data = stateData;\r\n    this.tracks = [];\r\n    this.events = [];\r\n};\r\nspine.AnimationState.prototype = {\r\n    onStart: null,\r\n    onEnd: null,\r\n    onComplete: null,\r\n    onEvent: null,\r\n    timeScale: 1,\r\n    update: function (delta)\r\n    {\r\n        delta *= this.timeScale;\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            current.time += delta * current.timeScale;\r\n            if (current.previous)\r\n            {\r\n                var previousDelta = delta * current.previous.timeScale;\r\n                current.previous.time += previousDelta;\r\n                current.mixTime += previousDelta;\r\n            }\r\n\r\n            var next = current.next;\r\n            if (next)\r\n            {\r\n                next.time = current.lastTime - next.delay;\r\n                if (next.time >= 0) this.setCurrent(i, next);\r\n            } else {\r\n                // End non-looping animation when it reaches its end time and there is no next entry.\r\n                if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);\r\n            }\r\n        }\r\n    },\r\n    apply: function (skeleton)\r\n    {\r\n        skeleton.resetDrawOrder();\r\n\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            this.events.length = 0;\r\n\r\n            var time = current.time;\r\n            var lastTime = current.lastTime;\r\n            var endTime = current.endTime;\r\n            var loop = current.loop;\r\n            if (!loop && time > endTime) time = endTime;\r\n\r\n            var previous = current.previous;\r\n            if (!previous)\r\n            {\r\n                if (current.mix == 1)\r\n                    current.animation.apply(skeleton, current.lastTime, time, loop, this.events);\r\n                else\r\n                    current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);\r\n            } else {\r\n                var previousTime = previous.time;\r\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\r\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\r\n\r\n                var alpha = current.mixTime / current.mixDuration * current.mix;\r\n                if (alpha >= 1)\r\n                {\r\n                    alpha = 1;\r\n                    current.previous = null;\r\n                }\r\n                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);\r\n            }\r\n\r\n            for (var ii = 0, nn = this.events.length; ii < nn; ii++)\r\n            {\r\n                var event = this.events[ii];\r\n                if (current.onEvent) current.onEvent(i, event);\r\n                if (this.onEvent) this.onEvent(i, event);\r\n            }\r\n\r\n            // Check if completed the animation or a loop iteration.\r\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime))\r\n            {\r\n                var count = Math.floor(time / endTime);\r\n                if (current.onComplete) current.onComplete(i, count);\r\n                if (this.onComplete) this.onComplete(i, count);\r\n            }\r\n\r\n            current.lastTime = current.time;\r\n        }\r\n    },\r\n    clearTracks: function ()\r\n    {\r\n        for (var i = 0, n = this.tracks.length; i < n; i++)\r\n            this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n    },\r\n    clearTrack: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        var current = this.tracks[trackIndex];\r\n        if (!current) return;\r\n\r\n        if (current.onEnd) current.onEnd(trackIndex);\r\n        if (this.onEnd) this.onEnd(trackIndex);\r\n\r\n        this.tracks[trackIndex] = null;\r\n    },\r\n    _expandToIndex: function (index)\r\n    {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        while (index >= this.tracks.length)\r\n            this.tracks.push(null);\r\n        return null;\r\n    },\r\n    setCurrent: function (index, entry)\r\n    {\r\n        var current = this._expandToIndex(index);\r\n        if (current)\r\n        {\r\n            var previous = current.previous;\r\n            current.previous = null;\r\n\r\n            if (current.onEnd) current.onEnd(index);\r\n            if (this.onEnd) this.onEnd(index);\r\n\r\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\r\n            if (entry.mixDuration > 0)\r\n            {\r\n                entry.mixTime = 0;\r\n                // If a mix is in progress, mix from the closest animation.\r\n                if (previous && current.mixTime / current.mixDuration < 0.5)\r\n                    entry.previous = previous;\r\n                else\r\n                    entry.previous = current;\r\n            }\r\n        }\r\n\r\n        this.tracks[index] = entry;\r\n\r\n        if (entry.onStart) entry.onStart(index);\r\n        if (this.onStart) this.onStart(index);\r\n    },\r\n    setAnimationByName: function (trackIndex, animationName, loop)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.setAnimation(trackIndex, animation, loop);\r\n    },\r\n    /** Set the current animation. Any queued animations are cleared. */\r\n    setAnimation: function (trackIndex, animation, loop)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n        this.setCurrent(trackIndex, entry);\r\n        return entry;\r\n    },\r\n    addAnimationByName: function (trackIndex, animationName, loop, delay)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.addAnimation(trackIndex, animation, loop, delay);\r\n    },\r\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\r\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\r\n    addAnimation: function (trackIndex, animation, loop, delay)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n\r\n        var last = this._expandToIndex(trackIndex);\r\n        if (last)\r\n        {\r\n            while (last.next)\r\n                last = last.next;\r\n            last.next = entry;\r\n        } else\r\n            this.tracks[trackIndex] = entry;\r\n\r\n        if (delay <= 0)\r\n        {\r\n            if (last)\r\n                delay += last.endTime - this.data.getMix(last.animation, animation);\r\n            else\r\n                delay = 0;\r\n        }\r\n        entry.delay = delay;\r\n\r\n        return entry;\r\n    },\r\n    /**\r\n     * Returns true if animation exists in skeleton data\r\n     * @param animationName\r\n     * @returns {boolean}\r\n     */\r\n    hasAnimationByName: function (animationName)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        return animation !== null;\r\n    },\r\n    /** May be null. */\r\n    getCurrent: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n        return this.tracks[trackIndex];\r\n    }\r\n};\r\nmodule.exports = spine.AnimationState;\r\n\r\n\n},{\"../SpineUtil\":44,\"./TrackEntry\":37}],4:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AnimationStateData = function (skeletonData)\r\n{\r\n    this.skeletonData = skeletonData;\r\n    this.animationToMixTime = {};\r\n};\r\nspine.AnimationStateData.prototype = {\r\n    defaultMix: 0,\r\n    setMixByName: function (fromName, toName, duration)\r\n    {\r\n        var from = this.skeletonData.findAnimation(fromName);\r\n        if (!from) throw \"Animation not found: \" + fromName;\r\n        var to = this.skeletonData.findAnimation(toName);\r\n        if (!to) throw \"Animation not found: \" + toName;\r\n        this.setMix(from, to, duration);\r\n    },\r\n    setMix: function (from, to, duration)\r\n    {\r\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\r\n    },\r\n    getMix: function (from, to)\r\n    {\r\n        var key = from.name + \":\" + to.name;\r\n        return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;\r\n    }\r\n};\r\nmodule.exports = spine.AnimationStateData;\r\n\r\n\n},{\"../SpineUtil\":44}],5:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\nvar syncImageLoaderAdapter = require('../loaders/syncImageLoaderAdapter.js')\r\n\r\nspine.Atlas = function(atlasText, loaderFunction, callback) {\r\n    this.pages = [];\r\n    this.regions = [];\r\n    if (typeof atlasText === \"string\") {\r\n        this.addSpineAtlas.call(this, atlasText, loaderFunction, callback);\r\n    }\r\n};\r\n\r\nspine.Atlas.prototype = {\r\n    addTexture: function(name, texture) {\r\n        var pages = this.pages;\r\n        var page = null;\r\n        for (var i=0;i<pages.length;i++) {\r\n            if (pages[i].rendererObject === texture.baseTexture) {\r\n                page = pages[i];\r\n                break;\r\n            }\r\n        }\r\n        if (page === null) {\r\n            page = new spine.AtlasPage();\r\n            page.name = 'texturePage';\r\n            var baseTexture = texture.baseTexture;\r\n            page.width = baseTexture.realWidth;\r\n            page.height = baseTexture.realHeight;\r\n            page.rendererObject = baseTexture;\r\n            //those fields are not relevant in Pixi\r\n            page.format = 'RGBA8888';\r\n            page.minFilter = page.magFilter = \"Nearest\";\r\n            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            pages.push(page);\r\n        }\r\n        var region = new spine.AtlasRegion();\r\n        region.name = name;\r\n        region.page = page;\r\n        region.texture = texture;\r\n        region.index = -1;\r\n        this.regions.push(region);\r\n        return region;\r\n    },\r\n    addTextureHash: function(textures, stripExtension) {\r\n        for (var key in textures) {\r\n            if (textures.hasOwnProperty(key)) {\r\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n            }\r\n        }\r\n    },\r\n    addSpineAtlas: function (atlasText, loaderFunction, callback)\r\n    {\r\n        //TODO: remove this legacy later\r\n        if (typeof loaderFunction !== \"function\") {\r\n            //old syntax\r\n            var baseUrl = loaderFunction;\r\n            var crossOrigin = callback;\r\n            loaderFunction = syncImageLoaderAdapter(baseUrl, crossOrigin);\r\n            callback = null;\r\n        }\r\n\r\n        this.texturesLoading = 0;\r\n\r\n        var self = this;\r\n\r\n        var reader = new spine.AtlasReader(atlasText);\r\n        var tuple = [];\r\n        tuple.length = 4;\r\n        var page = null;\r\n\r\n        iterateParser();\r\n\r\n        function iterateParser() {\r\n            while (true) {\r\n                var line = reader.readLine();\r\n                if (line === null) {\r\n                    return callback && callback(self);\r\n                }\r\n                line = reader.trim(line);\r\n                if (!line.length)\r\n                    page = null;\r\n                else if (!page) {\r\n                    page = new spine.AtlasPage();\r\n                    page.name = line;\r\n\r\n                    if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\r\n                        page.width = parseInt(tuple[0]);\r\n                        page.height = parseInt(tuple[1]);\r\n                        reader.readTuple(tuple);\r\n                    } else {\r\n                        //old format, detect width and height by texture\r\n                    }\r\n                    page.format = spine.Atlas.Format[tuple[0]];\r\n\r\n                    reader.readTuple(tuple);\r\n                    page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\r\n                    page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\r\n\r\n                    var direction = reader.readValue();\r\n                    page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n                    page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n                    if (direction == \"x\")\r\n                        page.uWrap = spine.Atlas.TextureWrap.repeat;\r\n                    else if (direction == \"y\")\r\n                        page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n                    else if (direction == \"xy\")\r\n                        page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n\r\n                    // @ivanpopelyshev: I so want to use generators and \"yield()\" here, or at least promises\r\n                    loaderFunction(line, function (texture) {\r\n                        page.rendererObject = texture;\r\n                        if (!texture.hasLoaded) {\r\n                            texture.width = page.width;\r\n                            texture.height = page.height;\r\n                        }\r\n                        self.pages.push(page);\r\n                        if (!page.width || !page.height) {\r\n                            page.width = texture.realWidth;\r\n                            page.height = texture.realHeight;\r\n                            if (!page.width || !page.height) {\r\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                            }\r\n                        }\r\n                        iterateParser();\r\n                    });\r\n                    break;\r\n                } else {\r\n                    var region = new spine.AtlasRegion();\r\n                    region.name = line;\r\n                    region.page = page;\r\n\r\n                    var rotate = reader.readValue() === \"true\" ? 6 : 0;\r\n\r\n                    reader.readTuple(tuple);\r\n                    var x = parseInt(tuple[0]);\r\n                    var y = parseInt(tuple[1]);\r\n\r\n                    reader.readTuple(tuple);\r\n                    var width = parseInt(tuple[0]);\r\n                    var height = parseInt(tuple[1]);\r\n\r\n                    var resolution = page.rendererObject.resolution;\r\n                    x /= resolution;\r\n                    y /= resolution;\r\n                    width /= resolution;\r\n                    height /= resolution;\r\n\r\n                    var frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\r\n\r\n                    if (reader.readTuple(tuple) == 4) { // split is optional\r\n                        region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                        if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\r\n                            region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                            reader.readTuple(tuple);\r\n                        }\r\n                    }\r\n\r\n                    var originalWidth = parseInt(tuple[0]) / resolution;\r\n                    var originalHeight = parseInt(tuple[1]) / resolution;\r\n                    reader.readTuple(tuple);\r\n                    var offsetX = parseInt(tuple[0]) / resolution;\r\n                    var offsetY = parseInt(tuple[1]) / resolution;\r\n\r\n                    var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\r\n                    var trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\r\n\r\n                    //TODO: pixiv3 uses different frame/crop/trim\r\n\r\n                    if (PIXI.VERSION[0] == '4') {\r\n                        // pixi v4.0.0\r\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame, orig, trim, rotate);\r\n                    } else {\r\n                        // pixi v3.0.11\r\n                        var frame2 = new PIXI.Rectangle(x, y, width, height);\r\n                        var crop = frame2.clone();\r\n                        trim.width = originalWidth;\r\n                        trim.height = originalHeight;\r\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame2, crop, trim, rotate);\r\n                    }\r\n\r\n                    region.index = parseInt(reader.readValue());\r\n                    region.texture._updateUvs();\r\n\r\n                    self.regions.push(region);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    findRegion: function (name)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n            if (regions[i].name == name) return regions[i];\r\n        return null;\r\n    },\r\n    dispose: function ()\r\n    {\r\n        var pages = this.pages;\r\n        for (var i = 0, n = pages.length; i < n; i++)\r\n            pages[i].rendererObject.destroy(true);\r\n    },\r\n    updateUVs: function (page)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n        {\r\n            var region = regions[i];\r\n            if (region.page != page) continue;\r\n            region.texture._updateUvs();\r\n        }\r\n    }\r\n};\r\n\r\nspine.Atlas.Format = {\r\n    alpha: 0,\r\n    intensity: 1,\r\n    luminanceAlpha: 2,\r\n    rgb565: 3,\r\n    rgba4444: 4,\r\n    rgb888: 5,\r\n    rgba8888: 6\r\n};\r\n\r\nspine.Atlas.TextureFilter = {\r\n    nearest: 0,\r\n    linear: 1,\r\n    mipMap: 2,\r\n    mipMapNearestNearest: 3,\r\n    mipMapLinearNearest: 4,\r\n    mipMapNearestLinear: 5,\r\n    mipMapLinearLinear: 6\r\n};\r\n\r\nspine.Atlas.TextureWrap = {\r\n    mirroredRepeat: 0,\r\n    clampToEdge: 1,\r\n    repeat: 2\r\n};\r\nmodule.exports = spine.Atlas;\r\n\n},{\"../SpineUtil\":44,\"../loaders/syncImageLoaderAdapter.js\":50,\"./AtlasPage\":7,\"./AtlasReader\":8,\"./AtlasRegion\":9}],6:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.RegionAttachment = require('./RegionAttachment');\r\nspine.MeshAttachment = require('./MeshAttachment');\r\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\r\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\r\nspine.AtlasAttachmentParser = function (atlas)\r\n{\r\n    this.atlas = atlas;\r\n};\r\nspine.AtlasAttachmentParser.prototype = {\r\n    newRegionAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\";\r\n        var attachment = new spine.RegionAttachment(name);\r\n        attachment.rendererObject = region;\r\n        attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\r\n        attachment.regionOffsetX = region.offsetX;\r\n        attachment.regionOffsetY = region.spineOffsetY;\r\n        attachment.regionWidth = region.width;\r\n        attachment.regionHeight = region.height;\r\n        attachment.regionOriginalWidth = region.originalWidth;\r\n        attachment.regionOriginalHeight = region.originalHeight;\r\n        return attachment;\r\n    },\r\n    newMeshAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\";\r\n        var attachment = new spine.MeshAttachment(name);\r\n        attachment.rendererObject = region;\r\n        // region.texture.on('update', spine.MeshAttachment.prototype.updateUVs.bind(attachment));\r\n        return attachment;\r\n    },\r\n    newWeightedMeshAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (skinned mesh attachment: \" + name + \")\";\r\n        var attachment = new spine.WeightedMeshAttachment(name);\r\n        attachment.rendererObject = region;\r\n        // region.texture.on('update', spine.WeightedMeshAttachment.prototype.updateUVs.bind(attachment));\r\n        return attachment;\r\n    },\r\n    newBoundingBoxAttachment: function (skin, name)\r\n    {\r\n        return new spine.BoundingBoxAttachment(name);\r\n    }\r\n};\r\nmodule.exports = spine.AtlasAttachmentParser;\r\n\r\n\n},{\"../SpineUtil\":44,\"./BoundingBoxAttachment\":14,\"./MeshAttachment\":25,\"./RegionAttachment\":26,\"./WeightedMeshAttachment\":42}],7:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AtlasPage = function ()\r\n{};\r\nspine.AtlasPage.prototype = {\r\n    name: null,\r\n    format: null,\r\n    minFilter: null,\r\n    magFilter: null,\r\n    uWrap: null,\r\n    vWrap: null,\r\n    rendererObject: null,\r\n    width: 0,\r\n    height: 0\r\n};\r\nmodule.exports = spine.AtlasPage;\r\n\r\n\n},{\"../SpineUtil\":44}],8:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AtlasReader = function (text)\r\n{\r\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n};\r\nspine.AtlasReader.prototype = {\r\n    index: 0,\r\n    trim: function (value)\r\n    {\r\n        return value.replace(/^\\s+|\\s+$/g, \"\");\r\n    },\r\n    readLine: function ()\r\n    {\r\n        if (this.index >= this.lines.length) return null;\r\n        return this.lines[this.index++];\r\n    },\r\n    readValue: function ()\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        return this.trim(line.substring(colon + 1));\r\n    },\r\n    /** Returns the number of tuple values read (1, 2 or 4). */\r\n    readTuple: function (tuple)\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        var i = 0, lastMatch = colon + 1;\r\n        for (; i < 3; i++)\r\n        {\r\n            var comma = line.indexOf(\",\", lastMatch);\r\n            if (comma == -1) break;\r\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\r\n            lastMatch = comma + 1;\r\n        }\r\n        tuple[i] = this.trim(line.substring(lastMatch));\r\n        return i + 1;\r\n    }\r\n};\r\nmodule.exports = spine.AtlasReader;\r\n\r\n\n},{\"../SpineUtil\":44}],9:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AtlasRegion = function ()\r\n{};\r\nspine.AtlasRegion.prototype = {\r\n    name: null,\r\n    /**\r\n     * @member {PIXI.Texture}\r\n     */\r\n    texture: null,\r\n\r\n    /**\r\n     * @member {PIXI.spine.Spine.AtlasPage}\r\n     */\r\n    page: null,\r\n    index: 0,\r\n    splits: null,\r\n    pads: null\r\n};\r\n\r\nObject.defineProperties(spine.AtlasRegion.prototype, {\r\n    x: {\r\n        get: function() {\r\n            return this.texture.frame.x;\r\n        }\r\n    },\r\n    y: {\r\n        get: function() {\r\n            return this.texture.frame.y;\r\n        }\r\n    },\r\n    width: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            if (PIXI.VERSION[0] == '3') {\r\n                return tex.crop.width;\r\n            }\r\n            if (tex.trim) {\r\n                return tex.trim.width;\r\n            }\r\n            return tex.orig.width;\r\n        }\r\n    },\r\n    height: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            if (PIXI.VERSION[0] == '3') {\r\n                return tex.crop.height;\r\n            }\r\n            if (tex.trim) {\r\n                return tex.trim.height;\r\n            }\r\n            return tex.orig.height;\r\n        }\r\n    },\r\n    u: {\r\n        get: function() {\r\n            return this.texture._uvs.x0;\r\n        }\r\n    },\r\n    v: {\r\n        get: function() {\r\n            return this.texture._uvs.y0;\r\n        }\r\n    },\r\n    u2: {\r\n        get: function() {\r\n            return this.texture._uvs.x2;\r\n        }\r\n    },\r\n    v2: {\r\n        get: function() {\r\n            return this.texture._uvs.y2;\r\n        }\r\n    },\r\n    rotate: {\r\n        get: function() {\r\n            return !!this.texture.rotate;\r\n        }\r\n    },\r\n    offsetX: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            return tex.trim ? tex.trim.x : 0;\r\n        }\r\n    },\r\n    offsetY: {\r\n        get: function() {\r\n            console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\r\n            return this.spineOffsetY;\r\n        }\r\n    },\r\n    pixiOffsetY: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            return tex.trim ? tex.trim.y : 0;\r\n        }\r\n    },\r\n    spineOffsetY: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\r\n        }\r\n    },  \r\n    originalWidth: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            if (PIXI.VERSION[0] == '3') {\r\n                if (tex.trim) {\r\n                    return tex.trim.width;\r\n                }\r\n                return tex.crop.width;\r\n            }\r\n            return tex.orig.width;\r\n        }\r\n    },\r\n    originalHeight: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            if (PIXI.VERSION[0] == '3') {\r\n                if (tex.trim) {\r\n                    return tex.trim.height;\r\n                }\r\n                return tex.crop.height;\r\n            }\r\n            return tex.orig.height;\r\n        }\r\n    }\r\n});\r\n\r\nmodule.exports = spine.AtlasRegion;\r\n\r\n\n},{\"../SpineUtil\":44}],10:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Curves = require('./Curves');\r\nspine.Animation = require('./Animation');\r\nspine.AttachmentTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.attachmentNames = [];\r\n    this.attachmentNames.length = frameCount;\r\n};\r\nspine.AttachmentTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, attachmentName)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n\r\n        var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;\r\n        if (frames[frameIndex] < lastTime) return;\r\n\r\n        var attachmentName = this.attachmentNames[frameIndex];\r\n        skeleton.slots[this.slotIndex].setAttachment(\r\n            !attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\r\n    }\r\n};\r\nmodule.exports = spine.AttachmentTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],11:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AttachmentType = {\r\n    region: 0,\r\n    boundingbox: 1,\r\n    mesh: 2,\r\n    weightedmesh : 3,\r\n    skinnedmesh: 3,\r\n    linkedmesh: 4,\r\n    weightedlinkedmesh: 5\r\n};\r\nmodule.exports = spine.AttachmentType;\r\n\r\n\n},{\"../SpineUtil\":44}],12:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Bone = function (boneData, skeleton, parent)\r\n{\r\n    this.data = boneData;\r\n    this.skeleton = skeleton;\r\n    this.parent = parent;\r\n    this.matrix = new PIXI.Matrix();\r\n    this.setToSetupPose();\r\n};\r\nspine.Bone.yDown = false;\r\nspine.Bone.prototype = {\r\n    x: 0, y: 0,\r\n    rotation: 0, rotationIK: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    shearX: 0, shearY: 0,\r\n    flipX: false, flipY: false,\r\n\r\n    worldSignX: 1, worldSignY: 1,\r\n    update: function() {\r\n        this.rotationIK = this.rotation;\r\n        this.updateWorldTransform();\r\n    },\r\n    updateWorldTransform: function() {\r\n        var rotation = this.rotationIK;\r\n        var scaleX = this.scaleX;\r\n        var scaleY = this.scaleY;\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var rotationX = rotation + this.shearX;\r\n        var rotationY = rotation + 90 + this.shearY;\r\n\r\n        var la = Math.cos(rotationX * spine.degRad) * scaleX, lb = Math.cos(rotationY * spine.degRad) * scaleY,\r\n            lc = Math.sin(rotationX * spine.degRad) * scaleX, ld = Math.sin(rotationY * spine.degRad) * scaleY;\r\n        var parent = this.parent;\r\n        var m = this.matrix;\r\n        var skeleton = this.skeleton;\r\n        if (!parent) { // Root bone.\r\n            if (skeleton.flipX) {\r\n                x = -x;\r\n                la = -la;\r\n                lb = -lb;\r\n            }\r\n            if (skeleton.flipY !== spine.Bone.yDown) {\r\n                y = -y;\r\n                lc = -lc;\r\n                ld = -ld;\r\n            }\r\n            m.a = la;\r\n            m.c = lb;\r\n            m.b = lc;\r\n            m.d = ld;\r\n            m.tx = x;\r\n            m.ty = y;\r\n            this.worldSignX = spine.signum(scaleX);\r\n            this.worldSignY = spine.signum(scaleY);\r\n            return;\r\n        }\r\n\r\n\r\n        var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\r\n        m.tx = pa * x + pb * y + parent.matrix.tx;\r\n        m.ty = pc * x + pd * y + parent.matrix.ty;\r\n        this.worldSignX = parent.worldSignX * spine.signum(scaleX);\r\n        this.worldSignY = parent.worldSignY * spine.signum(scaleY);\r\n        var data = this.data;\r\n\r\n        if (data.inheritRotation && data.inheritScale) {\r\n            m.a = pa * la + pb * lc;\r\n            m.c = pa * lb + pb * ld;\r\n            m.b = pc * la + pd * lc;\r\n            m.d = pc * lb + pd * ld;\r\n        } else {\r\n            if (data.inheritRotation) { // No scale inheritance.\r\n                pa = 1;\r\n                pb = 0;\r\n                pc = 0;\r\n                pd = 1;\r\n                do {\r\n                    cos = Math.cos(parent.rotationIK * spine.degRad);\r\n                    sin = Math.sin(parent.rotationIK * spine.degRad);\r\n                    var temp = pa * cos + pb * sin;\r\n                    pb = pa * -sin + pb * cos;\r\n                    pa = temp;\r\n                    temp = pc * cos + pd * sin;\r\n                    pd = pc * -sin + pd * cos;\r\n                    pc = temp;\r\n\r\n                    if (!parent.data.inheritRotation) break;\r\n                    parent = parent.parent;\r\n                } while (parent != null);\r\n                m.a = pa * la + pb * lc;\r\n                m.c = pa * lb + pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n            } else if (data.inheritScale) { // No rotation inheritance.\r\n                pa = 1;\r\n                pb = 0;\r\n                pc = 0;\r\n                pd = 1;\r\n                do {\r\n                    var r = parent.rotationIK;\r\n                    cos = Math.cos(r * spine.degRad);\r\n                    sin = Math.sin(r * spine.degRad);\r\n                    var psx = parent.scaleX, psy = parent.scaleY;\r\n                    var za = cos * psx, zb = -sin * psy, zc = sin * psx, zd = cos * psy;\r\n                    temp = pa * za + pb * zc;\r\n                    pb = pa * zb + pb * zd;\r\n                    pa = temp;\r\n                    temp = pc * za + pd * zc;\r\n                    pd = pc * zb + pd * zd;\r\n                    pc = temp;\r\n\r\n                    if (psx < 0) {\r\n                        r = -r;\r\n                    } else {\r\n                        sin = -sin;\r\n                    }\r\n                    temp = pa * cos + pb * sin;\r\n                    pb = pa * -sin + pb * cos;\r\n                    pa = temp;\r\n                    temp = pc * cos + pd * sin;\r\n                    pd = pc * -sin + pd * cos;\r\n                    pc = temp;\r\n\r\n                    if (!parent.data.inheritScale) break;\r\n                    parent = parent.parent;\r\n                } while (parent != null);\r\n                m.a = pa * la + pb * lc;\r\n                m.c = pa * lb + pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n            } else {\r\n                m.a = la;\r\n                m.c = lb;\r\n                m.b = lc;\r\n                m.d = ld;\r\n            }\r\n            if (skeleton.flipX) {\r\n                m.a = -m.a;\r\n                m.c = -m.c;\r\n            }\r\n            if (skeleton.flipY !== spine.Bone.yDown) {\r\n                m.b = -m.b;\r\n                m.d = -m.d;\r\n            }\r\n        }\r\n    },\r\n\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.x = data.x;\r\n        this.y = data.y;\r\n        this.rotation = data.rotation;\r\n        this.rotationIK = this.rotation;\r\n        this.scaleX = data.scaleX;\r\n        this.scaleY = data.scaleY;\r\n        this.shearX = data.shearX;\r\n        this.shearY = data.shearY;\r\n    },\r\n    worldToLocal: function (world)\r\n    {\r\n        var m = this.matrix;\r\n        var dx = world[0] - m.tx, dy = m.ty;\r\n        var invDet = 1 / (m.a * m.d - m.b * m.c);\r\n        //Yep, its a bug in original spine. I hope they'll fix it: https://github.com/EsotericSoftware/spine-runtimes/issues/544\r\n        world[0] = dx * m.a * invDet - dy * m.c * invDet;\r\n        world[1] = dy * m.d * invDet - dx * m.b * invDet;\r\n    },\r\n    localToWorld: function (local)\r\n    {\r\n        var localX = local[0], localY = local[1];\r\n        var m = this.matrix;\r\n        local[0] = localX * m.a + localY * m.c + m.tx;\r\n        local[1] = localX * m.b + localY * m.d + m.ty;\r\n    },\r\n    getWorldRotationX: function() {\r\n        return Math.atan2(this.matrix.b, this.matrix.a) * spine.radDeg;\r\n\r\n    },\r\n    getWorldRotationY: function() {\r\n        return Math.atan2(this.matrix.d, this.matrix.c) * spine.radDeg;\r\n    },\r\n    getWorldScaleX: function() {\r\n        var a = this.matrix.a;\r\n        var b = this.matrix.b;\r\n        return Math.sqrt(a*a+b*b);\r\n    },\r\n    getWorldScaleY: function() {\r\n        var c = this.matrix.c;\r\n        var d = this.matrix.d;\r\n        return Math.sqrt(c * c + d * d);\r\n    }\r\n};\r\n\r\nObject.defineProperties(spine.Bone.prototype, {\r\n    worldX: {\r\n        get: function() {\r\n            return this.matrix.tx;\r\n        }\r\n    },\r\n    worldY:  {\r\n        get: function() {\r\n            return this.matrix.ty;\r\n        }\r\n    }\r\n});\r\n\r\nmodule.exports = spine.Bone;\r\n\n},{\"../SpineUtil\":44}],13:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.BoneData = function (name, parent)\r\n{\r\n    this.name = name;\r\n    this.parent = parent;\r\n};\r\nspine.BoneData.prototype = {\r\n    length: 0,\r\n    x: 0, y: 0,\r\n    rotation: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    shearX: 0, shearY: 0,\r\n    inheritScale: true,\r\n    inheritRotation: true\r\n};\r\nmodule.exports = spine.BoneData;\r\n\r\n\n},{\"../SpineUtil\":44}],14:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.BoundingBoxAttachment = function (name)\r\n{\r\n    this.name = name;\r\n    this.vertices = [];\r\n};\r\nspine.BoundingBoxAttachment.prototype = {\r\n    type: spine.AttachmentType.boundingbox,\r\n    computeWorldVertices: function (x, y, bone, worldVertices)\r\n    {\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\r\n        var vertices = this.vertices;\r\n        for (var i = 0, n = vertices.length; i < n; i += 2)\r\n        {\r\n            var px = vertices[i];\r\n            var py = vertices[i + 1];\r\n            worldVertices[i] = px * m00 + py * m01 + x;\r\n            worldVertices[i + 1] = px * m10 + py * m11 + y;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.BoundingBoxAttachment;\r\n\r\n\n},{\"../SpineUtil\":44,\"./AttachmentType\":11}],15:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ColorTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, r, g, b, a, ...\r\n    this.frames.length = frameCount * 5;\r\n};\r\nspine.ColorTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 5;\r\n    },\r\n    setFrame: function (frameIndex, time, r, g, b, a)\r\n    {\r\n        frameIndex *= 5;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = r;\r\n        this.frames[frameIndex + 2] = g;\r\n        this.frames[frameIndex + 3] = b;\r\n        this.frames[frameIndex + 4] = a;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var r, g, b, a;\r\n        if (time >= frames[frames.length - 5])\r\n        {\r\n            // Time is after last frame.\r\n            var i = frames.length - 1;\r\n            r = frames[i - 3];\r\n            g = frames[i - 2];\r\n            b = frames[i - 1];\r\n            a = frames[i];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            var frameIndex = spine.Animation.binarySearch(frames, time, 5);\r\n            var prevFrameR = frames[frameIndex - 4];\r\n            var prevFrameG = frames[frameIndex - 3];\r\n            var prevFrameB = frames[frameIndex - 2];\r\n            var prevFrameA = frames[frameIndex - 1];\r\n            var frameTime = frames[frameIndex];\r\n            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*PREV_FRAME_TIME*/] - frameTime);\r\n            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\r\n\r\n            r = prevFrameR + (frames[frameIndex + 1/*FRAME_R*/] - prevFrameR) * percent;\r\n            g = prevFrameG + (frames[frameIndex + 2/*FRAME_G*/] - prevFrameG) * percent;\r\n            b = prevFrameB + (frames[frameIndex + 3/*FRAME_B*/] - prevFrameB) * percent;\r\n            a = prevFrameA + (frames[frameIndex + 4/*FRAME_A*/] - prevFrameA) * percent;\r\n        }\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        if (alpha < 1)\r\n        {\r\n            slot.r += (r - slot.r) * alpha;\r\n            slot.g += (g - slot.g) * alpha;\r\n            slot.b += (b - slot.b) * alpha;\r\n            slot.a += (a - slot.a) * alpha;\r\n        } else {\r\n            slot.r = r;\r\n            slot.g = g;\r\n            slot.b = b;\r\n            slot.a = a;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.ColorTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],16:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Curves = function (frameCount)\r\n{\r\n    this.curves = []; // type, x, y, ...\r\n    //this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;\r\n};\r\nspine.Curves.prototype = {\r\n    setLinear: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 0/*LINEAR*/;\r\n    },\r\n    setStepped: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 1/*STEPPED*/;\r\n    },\r\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\r\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\r\n     * the difference between the keyframe's values. */\r\n    setCurve: function (frameIndex, cx1, cy1, cx2, cy2)\r\n    {\r\n        var subdiv1 = 1 / 10/*BEZIER_SEGMENTS*/, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;\r\n        var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;\r\n        var tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;\r\n        var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;\r\n        var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;\r\n        var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;\r\n\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var curves = this.curves;\r\n        curves[i++] = 2/*BEZIER*/;\r\n\r\n        var x = dfx, y = dfy;\r\n        for (var n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    },\r\n    getCurvePercent: function (frameIndex, percent)\r\n    {\r\n        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\r\n        var curves = this.curves;\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var type = curves[i];\r\n        if (type === 0/*LINEAR*/) return percent;\r\n        if (type == 1/*STEPPED*/) return 0;\r\n        i++;\r\n        var x = 0;\r\n        for (var start = i, n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            x = curves[i];\r\n            if (x >= percent)\r\n            {\r\n                var prevX, prevY;\r\n                if (i == start)\r\n                {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n            }\r\n        }\r\n        var y = curves[i - 1];\r\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\r\n    }\r\n};\r\nmodule.exports = spine.Curves;\r\n\r\n\n},{\"../SpineUtil\":44}],17:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.DrawOrderTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.drawOrders = [];\r\n    this.drawOrders.length = frameCount;\r\n};\r\nspine.DrawOrderTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, drawOrder)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else\r\n            frameIndex = spine.Animation.binarySearch1(frames, time) - 1;\r\n\r\n        var drawOrder = skeleton.drawOrder;\r\n        var slots = skeleton.slots;\r\n        var drawOrderToSetupIndex = this.drawOrders[frameIndex];\r\n        if (drawOrderToSetupIndex)\r\n        {\r\n            for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n            {\r\n                drawOrder[i] = drawOrderToSetupIndex[i];\r\n            }\r\n        }\r\n\r\n    }\r\n};\r\nmodule.exports = spine.DrawOrderTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2}],18:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Event = function (data)\r\n{\r\n    this.data = data;\r\n};\r\nspine.Event.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.Event;\r\n\r\n\n},{\"../SpineUtil\":44}],19:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.EventData = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.EventData.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.EventData;\r\n\r\n\n},{\"../SpineUtil\":44}],20:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.EventTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.events = [];\r\n    this.events.length = frameCount;\r\n};\r\nspine.EventTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, event)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.events[frameIndex] = event;\r\n    },\r\n    /** Fires events for frames > lastTime and <= time. */\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        if (!firedEvents) return;\r\n\r\n        var frames = this.frames;\r\n        var frameCount = frames.length;\r\n\r\n        if (lastTime > time)\r\n        { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (lastTime < frames[0])\r\n            frameIndex = 0;\r\n        else\r\n        {\r\n            frameIndex = spine.Animation.binarySearch1(frames, lastTime);\r\n            var frame = frames[frameIndex];\r\n            while (frameIndex > 0)\r\n            { // Fire multiple events with the same frame.\r\n                if (frames[frameIndex - 1] != frame) break;\r\n                frameIndex--;\r\n            }\r\n        }\r\n        var events = this.events;\r\n        for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)\r\n            firedEvents.push(events[frameIndex]);\r\n    }\r\n};\r\nmodule.exports = spine.EventTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2}],21:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FfdTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = [];\r\n    this.frames.length = frameCount;\r\n    this.frameVertices = [];\r\n    this.frameVertices.length = frameCount;\r\n};\r\nspine.FfdTimeline.prototype = {\r\n    slotIndex: 0,\r\n    attachment: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, vertices)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        var slotAttachment = slot.attachment;\r\n        if (slotAttachment && (!slotAttachment.applyFFD || !slotAttachment.applyFFD(this.attachment))) return;\r\n\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameVertices = this.frameVertices;\r\n        var vertexCount = frameVertices[0].length;\r\n\r\n        var vertices = slot.attachmentVertices;\r\n        if (vertices.length != vertexCount) {\r\n            vertices = slot.attachmentVertices = [];\r\n            for (var k = 0; k < vertexCount; k++) vertices.push(0);\r\n            // Don't mix from uninitialized slot vertices.\r\n            alpha = 1;\r\n        }\r\n\r\n        if (time >= frames[frames.length - 1])\r\n        { // Time is after last frame.\r\n            var lastVertices = frameVertices[frames.length - 1];\r\n            if (alpha < 1)\r\n            {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\r\n            } else {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] = lastVertices[i];\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch1(frames, time);\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));\r\n\r\n        var prevVertices = frameVertices[frameIndex - 1];\r\n        var nextVertices = frameVertices[frameIndex];\r\n\r\n        if (alpha < 1)\r\n        {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.FfdTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],22:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.IkConstraint = function (data, skeleton)\r\n{\r\n    this.data = data;\r\n    this.mix = data.mix;\r\n    this.bendDirection = data.bendDirection;\r\n\r\n    this.bones = [];\r\n    for (var i = 0, n = data.bones.length; i < n; i++)\r\n        this.bones.push(skeleton.findBone(data.bones[i].name));\r\n    this.target = skeleton.findBone(data.target.name);\r\n};\r\nspine.IkConstraint.prototype = {\r\n    update: function() {\r\n        this.apply();\r\n    },\r\n    apply: function ()\r\n    {\r\n        var target = this.target;\r\n        var bones = this.bones;\r\n        switch (bones.length)\r\n        {\r\n        case 1:\r\n            spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);\r\n            break;\r\n        case 2:\r\n            spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\r\n            break;\r\n        }\r\n    }\r\n};\r\n/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\r\n * coordinate system. */\r\nspine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha)\r\n{\r\n    var parentRotation = bone.parent ? bone.parent.getWorldRotationX(): 0;\r\n    var rotation = bone.rotation;\r\n    var rotationIK = Math.atan2(targetY - bone.worldY, targetX - bone.worldX) * spine.radDeg - parentRotation;\r\n    if ((bone.worldSignX != bone.worldSignY) != (bone.skeleton.flipX != (bone.skeleton.flipY != spine.Bone.yDown))) rotationIK = 360 - rotationIK;\r\n\r\n    //OLD ONE:\r\n\r\n    // float parentRotation = bone.parent == null ? 0 : bone.parent.getWorldRotationX();\r\n    // float rotation = bone.rotation;\r\n    // float rotationIK = atan2(targetY - bone.worldY, targetX - bone.worldX) * radDeg - parentRotation;\r\n    // if ((bone.worldSignX != bone.worldSignY) != (bone.skeleton.flipX != bone.skeleton.flipY)) rotationIK = 360 - rotationIK;\r\n\r\n    //NEW ONE\r\n\r\n    // var pp = bone.parent;\r\n    // float id = 1 / (pp.a * pp.d - pp.b * pp.c);\r\n    // float x = targetX - pp.worldX, y = targetY - pp.worldY;\r\n    // float tx = (x * pp.d - y * pp.b) * id - bone.x, ty = (y * pp.a - x * pp.c) * id - bone.y;\r\n    // float rotationIK = atan2(ty, tx) * radDeg - bone.shearX;\r\n    // if (bone.scaleX < 0) rotationIK += 180;\r\n\r\n\r\n    if (rotationIK > 180)\r\n        rotationIK -= 360;\r\n    else if (rotationIK < -180) rotationIK += 360;\r\n    bone.rotationIK = rotation + (rotationIK - rotation) * alpha;\r\n    bone.updateWorldTransform();\r\n};\r\n/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\r\n * target is specified in the world coordinate system.\r\n * @param child Any descendant bone of the parent. */\r\nspine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDir, alpha)\r\n{\r\n    if (alpha == 0) return;\r\n    var px = parent.x, py = parent.y, psx = parent.scaleX, psy = parent.scaleY, csx = child.scaleX, cy = child.y;\r\n    var offset1, offset2, sign2;\r\n    if (psx < 0) {\r\n        psx = -psx;\r\n        offset1 = 180;\r\n        sign2 = -1;\r\n    } else {\r\n        offset1 = 0;\r\n        sign2 = 1;\r\n    }\r\n    if (psy < 0) {\r\n        psy = -psy;\r\n        sign2 = -sign2;\r\n    }\r\n    if (csx < 0) {\r\n        csx = -csx;\r\n        offset2 = 180;\r\n    } else\r\n        offset2 = 0;\r\n    var pp = parent.parent;\r\n    var ppm = pp.matrix;\r\n    var tx, ty, dx, dy;\r\n    if (pp == null) {\r\n        tx = targetX - px;\r\n        ty = targetY - py;\r\n        dx = child.worldX - px;\r\n        dy = child.worldY - py;\r\n    } else {\r\n        var a = ppm.a, b = ppm.c, c = ppm.b, d = ppm.d, invDet = 1 / (a * d - b * c);\r\n        var wx = ppm.tx, wy = ppm.ty, x = targetX - wx, y = targetY - wy;\r\n        tx = (x * d - y * b) * invDet - px;\r\n        ty = (y * a - x * c) * invDet - py;\r\n        x = child.worldX - wx;\r\n        y = child.worldY - wy;\r\n        dx = (x * d - y * b) * invDet - px;\r\n        dy = (y * a - x * c) * invDet - py;\r\n    }\r\n\r\n    //OLD ONE\r\n    // float tx, ty, dx, dy;\r\n    // if (pp == null) {\r\n    //     tx = targetX - px;\r\n    //     ty = targetY - py;\r\n    //     dx = child.worldX - px;\r\n    //     dy = child.worldY - py;\r\n    // } else {\r\n    //     float a = pp.a, b = pp.b, c = pp.c, d = pp.d, invDet = 1 / (a * d - b * c);\r\n    //     float wx = pp.worldX, wy = pp.worldY, x = targetX - wx, y = targetY - wy;\r\n    //     tx = (x * d - y * b) * invDet - px;\r\n    //     ty = (y * a - x * c) * invDet - py;\r\n    //     x = child.worldX - wx;\r\n    //     y = child.worldY - wy;\r\n    //     dx = (x * d - y * b) * invDet - px;\r\n    //     dy = (y * a - x * c) * invDet - py;\r\n    // }\r\n\r\n    //NEW ONE\r\n    // float ppa = pp.a, ppb = pp.b, ppc = pp.c, ppd = pp.d, id = 1 / (ppa * ppd - ppb * ppc);\r\n    // float x = targetX - pp.worldX, y = targetY - pp.worldY;\r\n    // float tx = (x * ppd - y * ppb) * id - px, ty = (y * ppa - x * ppc) * id - py;\r\n    // x = child.worldX - pp.worldX;\r\n    // y = child.worldY - pp.worldY;\r\n    // float dx = (x * ppd - y * ppb) * id - px, dy = (y * ppa - x * ppc) * id - py;\r\n\r\n    var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\r\n    outer:\r\n        if (Math.abs(psx - psy) <= 0.0001) {\r\n            l2 *= psx;\r\n            var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n            if (cos < -1)\r\n                cos = -1;\r\n            else if (cos > 1) cos = 1;\r\n            a2 = Math.acos(cos) * bendDir;\r\n            var a = l1 + l2 * cos, o = l2 * Math.sin(a2);\r\n            a1 = Math.atan2(ty * a - tx * o, tx * a + ty * o);\r\n        } else {\r\n            cy = 0;\r\n            var a = psx * l2, b = psy * l2, ta = Math.atan2(ty, tx);\r\n            var aa = a * a, bb = b * b, ll = l1 * l1, dd = tx * tx + ty * ty;\r\n            var c0 = bb * ll + aa * dd - aa * bb, c1 = -2 * bb * l1, c2 = bb - aa;\r\n            var d = c1 * c1 - 4 * c2 * c0;\r\n            if (d >= 0) {\r\n                var q = Math.sqrt(d);\r\n                if (c1 < 0) q = -q;\r\n                q = -(c1 + q) / 2;\r\n                var r0 = q / c2, r1 = c0 / q;\r\n                var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n                if (r * r <= dd) {\r\n                    var y = Math.sqrt(dd - r * r) * bendDir;\r\n                    a1 = ta - Math.atan2(y, r);\r\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\r\n                    break outer;\r\n                }\r\n            }\r\n            var minAngle = 0, minDist = Infinity, minX = 0, minY = 0;\r\n            var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;\r\n            var x = l1 + a, dist = x * x;\r\n            if (dist > maxDist) {\r\n                maxAngle = 0;\r\n                maxDist = dist;\r\n                maxX = x;\r\n            }\r\n            x = l1 - a;\r\n            dist = x * x;\r\n            if (dist < minDist) {\r\n                minAngle = Math.PI;\r\n                minDist = dist;\r\n                minX = x;\r\n            }\r\n            var angle = Math.acos(-a * l1 / (aa - bb));\r\n            x = a * Math.cos(angle) + l1;\r\n            var y = b * Math.sin(angle);\r\n            dist = x * x + y * y;\r\n            if (dist < minDist) {\r\n                minAngle = angle;\r\n                minDist = dist;\r\n                minX = x;\r\n                minY = y;\r\n            }\r\n            if (dist > maxDist) {\r\n                maxAngle = angle;\r\n                maxDist = dist;\r\n                maxX = x;\r\n                maxY = y;\r\n            }\r\n            if (dd <= (minDist + maxDist) / 2) {\r\n                a1 = ta - Math.atan2(minY * bendDir, minX);\r\n                a2 = minAngle * bendDir;\r\n            } else {\r\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n                a2 = maxAngle * bendDir;\r\n            }\r\n        }\r\n    var offset = Math.atan2(cy, child.x) * sign2;\r\n    a1 = (a1 - offset) * spine.radDeg + offset1;\r\n    a2 = (a2 + offset) * spine.radDeg * sign2 + offset2;\r\n    if (a1 > 180)\r\n        a1 -= 360;\r\n    else if (a1 < -180) a1 += 360;\r\n    if (a2 > 180)\r\n        a2 -= 360;\r\n    else if (a2 < -180) a2 += 360;\r\n    var rotation = parent.rotation;\r\n    parent.rotationIK = rotation + (a1 - rotation) * alpha;\r\n    parent.updateWorldTransform();\r\n    rotation = child.rotation;\r\n    child.rotationIK = rotation + (a2 - rotation) * alpha;\r\n    child.updateWorldTransform();\r\n};\r\nmodule.exports = spine.IkConstraint;\r\n\r\n\n},{\"../SpineUtil\":44}],23:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.IkConstraintData = function (name)\r\n{\r\n    this.name = name;\r\n    this.bones = [];\r\n};\r\nspine.IkConstraintData.prototype = {\r\n    target: null,\r\n    bendDirection: 1,\r\n    mix: 1\r\n};\r\nmodule.exports = spine.IkConstraintData;\r\n\r\n\n},{\"../SpineUtil\":44}],24:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.IkConstraintTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, mix, bendDirection, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.IkConstraintTimeline.prototype = {\r\n    ikConstraintIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, mix, bendDirection)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = mix;\r\n        this.frames[frameIndex + 2] = bendDirection;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;\r\n            ikConstraint.bendDirection = frames[frames.length - 1];\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameMix = frames[frameIndex + -2/*PREV_FRAME_MIX*/];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        var mix = prevFrameMix + (frames[frameIndex + 1/*FRAME_MIX*/] - prevFrameMix) * percent;\r\n        ikConstraint.mix += (mix - ikConstraint.mix) * alpha;\r\n        ikConstraint.bendDirection = frames[frameIndex + -1/*PREV_FRAME_BEND_DIRECTION*/];\r\n    }\r\n};\r\nmodule.exports = spine.IkConstraintTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],25:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.MeshAttachment = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.MeshAttachment.prototype = {\r\n    type: spine.AttachmentType.mesh,\r\n    parentMesh: null,\r\n    inheritFFD: false,\r\n    vertices: null,\r\n    uvs: null,\r\n    regionUVs: null,\r\n    triangles: null,\r\n    hullLength: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    edges: null,\r\n    width: 0, height: 0,\r\n    updateUVs: function ()\r\n    {\r\n        var n = this.regionUVs.length;\r\n        if (!this.uvs || this.uvs.length != n)\r\n        {\r\n            this.uvs = new spine.Float32Array(n);\r\n        }\r\n        var region = this.rendererObject;\r\n        if (!region) return;\r\n        var texture = region.texture;\r\n        var r = texture._uvs;\r\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\r\n        var x = region.offsetX, y = region.pixiOffsetY;\r\n        for (var i = 0; i < n; i += 2)\r\n        {\r\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\r\n            u = (u * w2 - x) / w1;\r\n            v = (v * h2 - y) / h1;\r\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\r\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\r\n        }\r\n    },\r\n    computeWorldVertices: function (x, y, slot, worldVertices)\r\n    {\r\n        var bone = slot.bone;\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\r\n        var vertices = this.vertices;\r\n        var verticesCount = vertices.length;\r\n        if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;\r\n        for (var i = 0; i < verticesCount; i += 2)\r\n        {\r\n            var vx = vertices[i];\r\n            var vy = vertices[i + 1];\r\n            worldVertices[i] = vx * m00 + vy * m01 + x;\r\n            worldVertices[i + 1] = vx * m10 + vy * m11 + y;\r\n        }\r\n    },\r\n    applyFFD: function(sourceAttachment) {\r\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\r\n    },\r\n    setParentMesh: function(parentMesh) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh != null) {\r\n            this.vertices = parentMesh.vertices;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n        }\r\n    },\r\n    hackRegion: function(newRegion) {\r\n        if (!newRegion) {\r\n            if (!this.oldRegion) return;\r\n            newRegion = this.oldRegion;\r\n        }\r\n        if (!this.oldRegion) {\r\n            this.oldRegion = this.rendererObject;\r\n        }\r\n        this.rendererObject = newRegion;\r\n        this.updateUVs();\r\n    }\r\n};\r\nmodule.exports = spine.MeshAttachment;\r\n\r\n\n},{\"../SpineUtil\":44,\"./AttachmentType\":11}],26:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.RegionAttachment = function (name)\r\n{\r\n    this.name = name;\r\n    this.offset = [];\r\n    this.offset.length = 8;\r\n    this.uvs = [];\r\n    this.uvs.length = 8;\r\n};\r\nspine.RegionAttachment.prototype = {\r\n    type: spine.AttachmentType.region,\r\n    x: 0, y: 0,\r\n    rotation: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    width: 0, height: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    regionOffsetX: 0, regionOffsetY: 0,\r\n    regionWidth: 0, regionHeight: 0,\r\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\r\n    setUVs: function (u, v, u2, v2, rotate)\r\n    {\r\n        var uvs = this.uvs;\r\n        if (rotate)\r\n        {\r\n            uvs[2/*X2*/] = u;\r\n            uvs[3/*Y2*/] = v2;\r\n            uvs[4/*X3*/] = u;\r\n            uvs[5/*Y3*/] = v;\r\n            uvs[6/*X4*/] = u2;\r\n            uvs[7/*Y4*/] = v;\r\n            uvs[0/*X1*/] = u2;\r\n            uvs[1/*Y1*/] = v2;\r\n        } else {\r\n            uvs[0/*X1*/] = u;\r\n            uvs[1/*Y1*/] = v2;\r\n            uvs[2/*X2*/] = u;\r\n            uvs[3/*Y2*/] = v;\r\n            uvs[4/*X3*/] = u2;\r\n            uvs[5/*Y3*/] = v;\r\n            uvs[6/*X4*/] = u2;\r\n            uvs[7/*Y4*/] = v2;\r\n        }\r\n    },\r\n    updateOffset: function ()\r\n    {\r\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\r\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\r\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\r\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\r\n        var localX2 = localX + this.regionWidth * regionScaleX;\r\n        var localY2 = localY + this.regionHeight * regionScaleY;\r\n        var radians = this.rotation * spine.degRad;\r\n        var cos = Math.cos(radians);\r\n        var sin = Math.sin(radians);\r\n        var localXCos = localX * cos + this.x;\r\n        var localXSin = localX * sin;\r\n        var localYCos = localY * cos + this.y;\r\n        var localYSin = localY * sin;\r\n        var localX2Cos = localX2 * cos + this.x;\r\n        var localX2Sin = localX2 * sin;\r\n        var localY2Cos = localY2 * cos + this.y;\r\n        var localY2Sin = localY2 * sin;\r\n        var offset = this.offset;\r\n        offset[0/*X1*/] = localXCos - localYSin;\r\n        offset[1/*Y1*/] = localYCos + localXSin;\r\n        offset[2/*X2*/] = localXCos - localY2Sin;\r\n        offset[3/*Y2*/] = localY2Cos + localXSin;\r\n        offset[4/*X3*/] = localX2Cos - localY2Sin;\r\n        offset[5/*Y3*/] = localY2Cos + localX2Sin;\r\n        offset[6/*X4*/] = localX2Cos - localYSin;\r\n        offset[7/*Y4*/] = localYCos + localX2Sin;\r\n    },\r\n    computeVertices: function (x, y, bone, vertices)\r\n    {\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\r\n        var offset = this.offset;\r\n        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\r\n        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\r\n        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\r\n        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\r\n        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\r\n        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\r\n        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\r\n        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\r\n    },\r\n    hackRegion: function(newRegion) {\r\n        if (!newRegion) {\r\n            if (!this.oldRegion) return;\r\n            newRegion = this.oldRegion;\r\n        }\r\n        if (!this.oldRegion) {\r\n            this.oldRegion = this.rendererObject;\r\n            this.oldRegion.size = { width: this.width, height: this.height };\r\n        }\r\n        this.rendererObject = newRegion;\r\n        if (newRegion.size) {\r\n            this.width = newRegion.size.width;\r\n            this.height = newRegion.size.height;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.RegionAttachment;\r\n\r\n\n},{\"../SpineUtil\":44,\"./AttachmentType\":11}],27:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.RotateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, angle, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.RotateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, angle)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = angle;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 2])\r\n        { // Time is after last frame.\r\n            var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\r\n            while (amount > 180)\r\n                amount -= 360;\r\n            while (amount < -180)\r\n                amount += 360;\r\n            bone.rotation += amount * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 2);\r\n        var prevFrameValue = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\r\n\r\n        var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - prevFrameValue;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        bone.rotation += amount * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.RotateTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],28:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ScaleTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ScaleTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;\r\n            bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;\r\n        bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ScaleTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],29:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ShearTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ShearTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.shearX += (bone.data.shearX + frames[frames.length - 2] - bone.shearX) * alpha;\r\n            bone.shearY += (bone.data.shearY + frames[frames.length - 1] - bone.shearY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.shearX += (bone.data.shearX + (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.shearX) * alpha;\r\n        bone.shearY += (bone.data.shearY + (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.shearY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ShearTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],30:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Bone = require('./Bone');\r\nspine.Slot = require('./Slot');\r\nspine.IkConstraint = require('./IkConstraint');\r\nspine.Skeleton = function (skeletonData)\r\n{\r\n    this.data = skeletonData;\r\n\r\n    this.bones = [];\r\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++)\r\n    {\r\n        var boneData = skeletonData.bones[i];\r\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\r\n        this.bones.push(new spine.Bone(boneData, this, parent));\r\n    }\r\n\r\n    this.slots = [];\r\n    this.drawOrder = [];\r\n    for (var i = 0, n = skeletonData.slots.length; i < n; i++)\r\n    {\r\n        var slotData = skeletonData.slots[i];\r\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\r\n        var slot = new spine.Slot(slotData, bone);\r\n        this.slots.push(slot);\r\n        this.drawOrder.push(i);\r\n    }\r\n\r\n    this.ikConstraints = [];\r\n    for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++)\r\n        this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));\r\n\r\n    this.transformConstraints = [];\r\n    for (var i = 0, n = skeletonData.transformConstraints.length; i < n; i++)\r\n        this.transformConstraints.push(new spine.TransformConstraint(skeletonData.transformConstraints[i], this));\r\n\r\n    this.boneCache = [];\r\n    this.updateCache();\r\n};\r\nspine.Skeleton.prototype = {\r\n    x: 0, y: 0,\r\n    skin: null,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    time: 0,\r\n    flipX: false, flipY: false,\r\n    /** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */\r\n    updateCache: function ()\r\n    {\r\n        var ikConstraints = this.ikConstraints;\r\n        var ikConstraintsCount = ikConstraints.length;\r\n        var transformConstraints = this.transformConstraints;\r\n        var transformConstraintsCount = transformConstraints.length;\r\n\r\n        var boneCache = this.boneCache;\r\n        boneCache.length = 0;\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n        {\r\n            var bone = bones[i];\r\n            boneCache.push(bone);\r\n            for (var j=0; j < transformConstraintsCount; j++) {\r\n                if (transformConstraints[j].bone == bone) {\r\n                    boneCache.push(transformConstraints[j]);\r\n                }\r\n            }\r\n            for (var j=0; j < ikConstraintsCount; j++) {\r\n                if (ikConstraints[j].bones[ikConstraints[j].bones.length-1] == bone) {\r\n                    boneCache.push(ikConstraints[j]);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    },\r\n    /** Updates the world transform for each bone. */\r\n    updateWorldTransform: function ()\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n        {\r\n            var bone = bones[i];\r\n            bone.rotationIK = bone.rotation;\r\n        }\r\n        var boneCache = this.boneCache;\r\n        for (var i = 0, n = boneCache.length; i < n; i++) {\r\n            boneCache[i].update();\r\n        }\r\n    },\r\n    /** Sets the bones and slots to their setup pose values. */\r\n    setToSetupPose: function ()\r\n    {\r\n        this.setBonesToSetupPose();\r\n        this.setSlotsToSetupPose();\r\n    },\r\n    setBonesToSetupPose: function ()\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            bones[i].setToSetupPose();\r\n\r\n        var ikConstraints = this.ikConstraints;\r\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\r\n        {\r\n            var ikConstraint = ikConstraints[i];\r\n            ikConstraint.bendDirection = ikConstraint.data.bendDirection;\r\n            ikConstraint.mix = ikConstraint.data.mix;\r\n        }\r\n\r\n        var transformConstraints = this.transformConstraints;\r\n        for (var i = 0, n = transformConstraints.length; i < n; i++)\r\n        {\r\n            var constraint = transformConstraints[i];\r\n            var data = constraint.data;\r\n            constraint.rotateMix = data.rotateMix;\r\n            constraint.translateMix = data.translateMix;\r\n            constraint.scaleMix = data.scaleMix;\r\n            constraint.shearMix = data.shearMix;\r\n        }\r\n    },\r\n    setSlotsToSetupPose: function ()\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            slots[i].setToSetupPose(i);\r\n        }\r\n\r\n        this.resetDrawOrder();\r\n    },\r\n    /** @return May return null. */\r\n    getRootBone: function ()\r\n    {\r\n        return this.bones.length ? this.bones[0] : null;\r\n    },\r\n    /** @return May be null. */\r\n    findBone: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return bones[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findBoneIndex: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return i;\r\n        return -1;\r\n    },\r\n    /** @return May be null. */\r\n    findSlot: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return slots[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findSlotIndex: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return i;\r\n        return -1;\r\n    },\r\n    setSkinByName: function (skinName)\r\n    {\r\n        var skin = this.data.findSkin(skinName);\r\n        if (!skin) throw \"Skin not found: \" + skinName;\r\n        this.setSkin(skin);\r\n    },\r\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\r\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was\r\n     * no old skin, each slot's setup mode attachment is attached from the new skin.\r\n     * @param newSkin May be null. */\r\n    setSkin: function (newSkin)\r\n    {\r\n        if (newSkin)\r\n        {\r\n            if (this.skin)\r\n                newSkin._attachAll(this, this.skin);\r\n            else\r\n            {\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++)\r\n                {\r\n                    var slot = slots[i];\r\n                    var name = slot.data.attachmentName;\r\n                    if (name)\r\n                    {\r\n                        var attachment = newSkin.getAttachment(i, name);\r\n                        if (attachment) slot.setAttachment(attachment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.skin = newSkin;\r\n    },\r\n    /** @return May be null. */\r\n    getAttachmentBySlotName: function (slotName, attachmentName)\r\n    {\r\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\r\n    },\r\n    /** @return May be null. */\r\n    getAttachmentBySlotIndex: function (slotIndex, attachmentName)\r\n    {\r\n        if (this.skin)\r\n        {\r\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n            if (attachment) return attachment;\r\n        }\r\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n        return null;\r\n    },\r\n    /** @param attachmentName May be null. */\r\n    setAttachment: function (slotName, attachmentName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            var slot = slots[i];\r\n            if (slot.data.name == slotName)\r\n            {\r\n                var attachment = null;\r\n                if (attachmentName)\r\n                {\r\n                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);\r\n                    if (!attachment) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\r\n                }\r\n                slot.setAttachment(attachment);\r\n                return;\r\n            }\r\n        }\r\n        throw \"Slot not found: \" + slotName;\r\n    },\r\n    /** @return May be null. */\r\n    findIkConstraint: function (constraintName)\r\n    {\r\n        var constraints = this.ikConstraints;\r\n        for (var i = 0, n = constraints.length; i < n; i++)\r\n            if (constraints[i].data.name == constraintName) return constraints[i];\r\n        return null;\r\n    },\r\n    findTransformConstraint: function (constraintName)\r\n    {\r\n        var constraints = this.transformConstraints;\r\n        for (var i = 0, n = constraints.length; i < n; i++)\r\n            if (constraints[i].data.name == constraintName) return constraints[i];\r\n        return null;\r\n    },\r\n    update: function (delta)\r\n    {\r\n        this.time += delta;\r\n    },\r\n    resetDrawOrder: function () {\r\n        for (var i = 0, n = this.drawOrder.length; i < n; i++)\r\n        {\r\n            this.drawOrder[i] = i;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skeleton;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Bone\":12,\"./IkConstraint\":22,\"./Slot\":35}],31:[function(require,module,exports){\nvar spine = require('../SpineRuntime') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.SkeletonBounds = function ()\r\n{\r\n    this.polygonPool = [];\r\n    this.polygons = [];\r\n    this.boundingBoxes = [];\r\n};\r\nspine.SkeletonBounds.prototype = {\r\n    minX: 0, minY: 0, maxX: 0, maxY: 0,\r\n    update: function (skeleton, updateAabb)\r\n    {\r\n        var slots = skeleton.slots;\r\n        var slotCount = slots.length;\r\n        var x = skeleton.x, y = skeleton.y;\r\n        var boundingBoxes = this.boundingBoxes;\r\n        var polygonPool = this.polygonPool;\r\n        var polygons = this.polygons;\r\n\r\n        boundingBoxes.length = 0;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            polygonPool.push(polygons[i]);\r\n        polygons.length = 0;\r\n\r\n        for (var i = 0; i < slotCount; i++)\r\n        {\r\n            var slot = slots[i];\r\n            var boundingBox = slot.attachment;\r\n            if (boundingBox.type != spine.AttachmentType.boundingbox) continue;\r\n            boundingBoxes.push(boundingBox);\r\n\r\n            var poolCount = polygonPool.length, polygon;\r\n            if (poolCount > 0)\r\n            {\r\n                polygon = polygonPool[poolCount - 1];\r\n                polygonPool.splice(poolCount - 1, 1);\r\n            } else\r\n                polygon = [];\r\n            polygons.push(polygon);\r\n\r\n            polygon.length = boundingBox.vertices.length;\r\n            boundingBox.computeWorldVertices(x, y, slot.bone, polygon);\r\n        }\r\n\r\n        if (updateAabb) this.aabbCompute();\r\n    },\r\n    aabbCompute: function ()\r\n    {\r\n        var polygons = this.polygons;\r\n        var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n        {\r\n            var vertices = polygons[i];\r\n            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2)\r\n            {\r\n                var x = vertices[ii];\r\n                var y = vertices[ii + 1];\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint: function (x, y)\r\n    {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n            return false;\r\n        var m = (y2 - y1) / (x2 - x1);\r\n        var y = m * (minX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        var x = (minY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        return false;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton: function (bounds)\r\n    {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\r\n    containsPoint: function (x, y)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually\r\n     * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */\r\n    intersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns true if the polygon contains the point. */\r\n    polygonContainsPoint: function (polygon, x, y)\r\n    {\r\n        var nn = polygon.length;\r\n        var prevIndex = nn - 2;\r\n        var inside = false;\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var vertexY = polygon[ii + 1];\r\n            var prevY = polygon[prevIndex + 1];\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y))\r\n            {\r\n                var vertexX = polygon[ii];\r\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n        return inside;\r\n    },\r\n    /** Returns true if the polygon contains the line segment. */\r\n    polygonIntersectsSegment: function (polygon, x1, y1, x2, y2)\r\n    {\r\n        var nn = polygon.length;\r\n        var width12 = x1 - x2, height12 = y1 - y2;\r\n        var det1 = x1 * y2 - y1 * x2;\r\n        var x3 = polygon[nn - 2], y3 = polygon[nn - 1];\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var x4 = polygon[ii], y4 = polygon[ii + 1];\r\n            var det2 = x3 * y4 - y3 * x4;\r\n            var width34 = x3 - x4, height34 = y3 - y4;\r\n            var det3 = width12 * height34 - height12 * width34;\r\n            var x = (det1 * width34 - width12 * det2) / det3;\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1)))\r\n            {\r\n                var y = (det1 * height34 - height12 * det2) / det3;\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n        return false;\r\n    },\r\n    getPolygon: function (attachment)\r\n    {\r\n        var index = this.boundingBoxes.indexOf(attachment);\r\n        return index == -1 ? null : this.polygons[index];\r\n    },\r\n    getWidth: function ()\r\n    {\r\n        return this.maxX - this.minX;\r\n    },\r\n    getHeight: function ()\r\n    {\r\n        return this.maxY - this.minY;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonBounds;\r\n\r\n\n},{\"../SpineRuntime\":43,\"./AttachmentType\":11}],32:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.SkeletonData = function ()\r\n{\r\n    this.bones = [];\r\n    this.slots = [];\r\n    this.skins = [];\r\n    this.events = [];\r\n    this.animations = [];\r\n    this.ikConstraints = [];\r\n    this.transformConstraints = [];\r\n};\r\nspine.SkeletonData.prototype = {\r\n    name: null,\r\n    defaultSkin: null,\r\n    width: 0, height: 0,\r\n    version: null, hash: null,\r\n    /** @return May be null. */\r\n    findBone: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].name == boneName) return bones[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findBoneIndex: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].name == boneName) return i;\r\n        return -1;\r\n    },\r\n    /** @return May be null. */\r\n    findSlot: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            if (slots[i].name == slotName) return this.slots[i];\r\n        }\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findSlotIndex: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].name == slotName) return i;\r\n        return -1;\r\n    },\r\n    /** @return May be null. */\r\n    findSkin: function (skinName)\r\n    {\r\n        var skins = this.skins;\r\n        for (var i = 0, n = skins.length; i < n; i++)\r\n            if (skins[i].name == skinName) return skins[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findEvent: function (eventName)\r\n    {\r\n        var events = this.events;\r\n        for (var i = 0, n = events.length; i < n; i++)\r\n            if (events[i].name == eventName) return events[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findAnimation: function (animationName)\r\n    {\r\n        var animations = this.animations;\r\n        for (var i = 0, n = animations.length; i < n; i++)\r\n            if (animations[i].name == animationName) return animations[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findIkConstraint: function (constraintName)\r\n    {\r\n        var constraints = this.ikConstraints;\r\n        for (var i = 0, n = constraints.length; i < n; i++)\r\n            if (constraints[i].name == constraintName) return constraints[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findTransformConstraint: function (constraintName)\r\n    {\r\n        var constraints = this.transformConstraints;\r\n        for (var i = 0, n = constraints.length; i < n; i++)\r\n            if (constraints[i].name == constraintName) return constraints[i];\r\n        return null;\r\n    },\r\n};\r\nmodule.exports = spine.SkeletonData;\r\n\r\n\n},{\"../SpineUtil\":44}],33:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.SkeletonData = require('./SkeletonData');\r\nspine.BoneData = require('./BoneData');\r\nspine.IkConstraintData = require('./IkConstraintData');\r\nspine.TransformConstraintData = require('./TransformConstraintData');\r\nspine.SlotData = require('./SlotData');\r\nspine.Skin = require('./Skin');\r\nspine.EventData = require('./EventData');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.ColorTimeline = require('./ColorTimeline');\r\nspine.AttachmentTimeline = require('./AttachmentTimeline');\r\nspine.RotateTimeline = require('./RotateTimeline');\r\nspine.ScaleTimeline = require('./ScaleTimeline');\r\nspine.TranslateTimeline = require('./TranslateTimeline');\r\nspine.ShearTimeline = require('./ShearTimeline');\r\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\r\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\r\nspine.FfdTimeline = require('./FfdTimeline');\r\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\r\nspine.EventTimeline = require('./EventTimeline');\r\nspine.Event = require('./Event');\r\nspine.Animation = require('./Animation');\r\n\r\nfunction LinkedMesh(mesh, skin, slotIndex, parent) {\r\n    this.mesh = mesh;\r\n    this.skin = skin;\r\n    this.slotIndex = slotIndex;\r\n    this.parent = parent;\r\n}\r\n\r\nspine.SkeletonJsonParser = function (attachmentLoader)\r\n{\r\n    if (attachmentLoader.pages) {\r\n        //its an atlas, we have to wrap it\r\n        this.attachmentLoader = new spine.AtlasAttachmentLoader(attachmentLoader);\r\n    } else {\r\n        //got a loader, thats good\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n    if (!attachmentLoader.newRegionAttachment) {\r\n        console.warn(\"SkeletonJsonParser accepts AtlasAttachmentLoader or atlas as first parameter\");\r\n    }\r\n    this.linkedMeshes = [];\r\n};\r\nspine.SkeletonJsonParser.prototype = {\r\n    scale: 1,\r\n    readSkeletonData: function (root, name)\r\n    {\r\n        var skeletonData = new spine.SkeletonData();\r\n        skeletonData.name = name;\r\n\r\n        var scale = this.scale;\r\n        // Skeleton.\r\n        var skeletonMap = root[\"skeleton\"];\r\n        if (skeletonMap)\r\n        {\r\n            skeletonData.hash = skeletonMap[\"hash\"];\r\n            skeletonData.version = skeletonMap[\"spine\"];\r\n            skeletonData.width = skeletonMap[\"width\"] || 0;\r\n            skeletonData.height = skeletonMap[\"height\"] || 0;\r\n        }\r\n\r\n        // Bones.\r\n        var bones = root[\"bones\"];\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n        {\r\n            var boneMap = bones[i];\r\n            var parent = null;\r\n            if (boneMap[\"parent\"])\r\n            {\r\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\r\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\r\n            }\r\n            var boneData = new spine.BoneData(boneMap[\"name\"], parent);\r\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\r\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\r\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\r\n            boneData.rotation = (boneMap[\"rotation\"] || 0);\r\n            boneData.scaleX = boneMap.hasOwnProperty(\"scaleX\") ? boneMap[\"scaleX\"] : 1;\r\n            boneData.scaleY = boneMap.hasOwnProperty(\"scaleY\") ? boneMap[\"scaleY\"] : 1;\r\n            boneData.shearX = boneMap[\"shearX\"] || 0;\r\n            boneData.shearY = boneMap[\"shearY\"] || 0;\r\n            boneData.inheritScale = boneMap.hasOwnProperty(\"inheritScale\") ? boneMap[\"inheritScale\"] : true;\r\n            boneData.inheritRotation = boneMap.hasOwnProperty(\"inheritRotation\") ? boneMap[\"inheritRotation\"] : true;\r\n            skeletonData.bones.push(boneData);\r\n        }\r\n\r\n        // IK constraints.\r\n        var ik = root[\"ik\"];\r\n        if (ik)\r\n        {\r\n            for (var i = 0, n = ik.length; i < n; i++)\r\n            {\r\n                var ikMap = ik[i];\r\n                var ikConstraintData = new spine.IkConstraintData(ikMap[\"name\"]);\r\n\r\n                var bones = ikMap[\"bones\"];\r\n                for (var ii = 0, nn = bones.length; ii < nn; ii++)\r\n                {\r\n                    var bone = skeletonData.findBone(bones[ii]);\r\n                    if (!bone) throw new Error( \"IK bone not found: \" + bones[ii] );\r\n                    ikConstraintData.bones.push(bone);\r\n                }\r\n\r\n                ikConstraintData.target = skeletonData.findBone(ikMap[\"target\"]);\r\n                if (!ikConstraintData.target) throw new Error(\"Target bone not found: \" + ikMap[\"target\"]);\r\n\r\n                ikConstraintData.bendDirection = (!ikMap.hasOwnProperty(\"bendPositive\") || ikMap[\"bendPositive\"]) ? 1 : -1;\r\n                ikConstraintData.mix = ikMap.hasOwnProperty(\"mix\") ? ikMap[\"mix\"] : 1;\r\n\r\n                skeletonData.ikConstraints.push(ikConstraintData);\r\n            }\r\n        }\r\n\r\n        var transform = root[\"transform\"];\r\n        if (transform) {\r\n            for (var i = 0, n = transform.length; i<n; i++) {\r\n                var transformMap = transform[i];\r\n                var transformData = new spine.TransformConstraintData(transformMap[\"name\"]);\r\n                transformData.bone = skeletonData.findBone(transformMap[\"bone\"]);\r\n                if (!transformData.bone) throw new Error(\"Transform bone not found: \" + transformData[\"bone\"]);\r\n                transformData.target = skeletonData.findBone(transformMap[\"target\"]);\r\n                if (!transformData.target) throw new Error(\"Target bone not found: \" + transformData[\"target\"]);\r\n\r\n                transformData.offsetRotation = transformMap[\"rotation\"] || 0;\r\n                transformData.offsetX = (transformMap[\"offsetX\"] || 0) * scale;\r\n                transformData.offsetY = (transformMap[\"offsetY\"] || 0) * scale;\r\n                transformData.offsetScaleX = (transformMap[\"scaleX\"] || 0) * scale;\r\n                transformData.offsetScaleY = (transformMap[\"scaleY\"] || 0) * scale;\r\n                transformData.offsetShearY = (transformMap[\"offsetShearY\"] || 0) * scale;\r\n\r\n                transformData.rotateMix = transformMap.hasOwnProperty(\"rotateMix\") ? transformMap[\"rotateMix\"] : 1;\r\n                transformData.translateMix = transformMap.hasOwnProperty(\"translateMix\") ? transformMap[\"translateMix\"] : 1;\r\n                transformData.scaleMix = transformMap.hasOwnProperty(\"scaleMix\") ? transformMap[\"scaleMix\"] : 1;\r\n                transformData.shearMix = transformMap.hasOwnProperty(\"shearMix\") ? transformMap[\"shearMix\"] : 1;\r\n\r\n                skeletonData.transformConstraints.push(transformData);\r\n            }\r\n        }\r\n\r\n        // Slots.\r\n        var slots = root[\"slots\"];\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            var slotMap = slots[i];\r\n            var boneData = skeletonData.findBone(slotMap[\"bone\"]);\r\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\r\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\r\n\r\n            var color = slotMap[\"color\"];\r\n            if (color)\r\n            {\r\n                slotData.r = this.toColor(color, 0);\r\n                slotData.g = this.toColor(color, 1);\r\n                slotData.b = this.toColor(color, 2);\r\n                slotData.a = this.toColor(color, 3);\r\n            }\r\n\r\n            slotData.attachmentName = slotMap[\"attachment\"];\r\n\r\n\r\n            slotData.blendMode = slotMap[\"blend\"] && spine.SlotData.PIXI_BLEND_MODE_MAP[slotMap[\"blend\"]] || spine.SlotData.PIXI_BLEND_MODE_MAP['normal'];\r\n\r\n            skeletonData.slots.push(slotData);\r\n        }\r\n\r\n        // Skins.\r\n        var skins = root[\"skins\"];\r\n        for (var skinName in skins)\r\n        {\r\n            if (!skins.hasOwnProperty(skinName)) continue;\r\n            var skinMap = skins[skinName];\r\n            var skin = new spine.Skin(skinName);\r\n            for (var slotName in skinMap)\r\n            {\r\n                if (!skinMap.hasOwnProperty(slotName)) continue;\r\n                var slotIndex = skeletonData.findSlotIndex(slotName);\r\n                var slotEntry = skinMap[slotName];\r\n                for (var attachmentName in slotEntry)\r\n                {\r\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\r\n                    var attachment = this.readAttachment(skin, slotIndex, attachmentName, slotEntry[attachmentName]);\r\n                    if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);\r\n                }\r\n            }\r\n            skeletonData.skins.push(skin);\r\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\r\n        }\r\n\r\n        var linkedMeshes = this.linkedMeshes;\r\n        // Linked meshes.\r\n        for (var i = 0, n = linkedMeshes.size; i < n; i++) {\r\n            var linkedMesh = linkedMeshes[i];\r\n            var skin = linkedMesh.skin ? skeletonData.findSkin(linkedMesh.skin): skeletonData.defaultSkin;\r\n            var parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n            linkedMesh.mesh.setParentMesh(parent);\r\n            linkedMesh.mesh.updateUVs();\r\n        }\r\n        linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        var events = root[\"events\"];\r\n        for (var eventName in events)\r\n        {\r\n            if (!events.hasOwnProperty(eventName)) continue;\r\n            var eventMap = events[eventName];\r\n            var eventData = new spine.EventData(eventName);\r\n            eventData.intValue = eventMap[\"int\"] || 0;\r\n            eventData.floatValue = eventMap[\"float\"] || 0;\r\n            eventData.stringValue = eventMap[\"string\"] || null;\r\n            skeletonData.events.push(eventData);\r\n        }\r\n\r\n        // Animations.\r\n        var animations = root[\"animations\"];\r\n        for (var animationName in animations)\r\n        {\r\n            if (!animations.hasOwnProperty(animationName)) continue;\r\n            this.readAnimation(animationName, animations[animationName], skeletonData);\r\n        }\r\n\r\n        return skeletonData;\r\n    },\r\n    readAttachment: function (skin, slotIndex, name, map)\r\n    {\r\n        name = map[\"name\"] || name;\r\n\r\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\r\n        var path = map[\"path\"] || name;\r\n\r\n        var scale = this.scale;\r\n        if (type == spine.AttachmentType.region)\r\n        {\r\n            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n            if (!region) return null;\r\n            region.path = path;\r\n            region.x = (map[\"x\"] || 0) * scale;\r\n            region.y = (map[\"y\"] || 0) * scale;\r\n            region.scaleX = map.hasOwnProperty(\"scaleX\") ? map[\"scaleX\"] : 1;\r\n            region.scaleY = map.hasOwnProperty(\"scaleY\") ? map[\"scaleY\"] : 1;\r\n            region.rotation = map[\"rotation\"] || 0;\r\n            region.width = (map[\"width\"] || 0) * scale;\r\n            region.height = (map[\"height\"] || 0) * scale;\r\n\r\n            var color = map[\"color\"];\r\n            if (color)\r\n            {\r\n                region.r = this.toColor(color, 0);\r\n                region.g = this.toColor(color, 1);\r\n                region.b = this.toColor(color, 2);\r\n                region.a = this.toColor(color, 3);\r\n            }\r\n\r\n            region.updateOffset();\r\n            return region;\r\n        } else if (type == spine.AttachmentType.boundingbox)\r\n        {\r\n            var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n            var vertices = map[\"vertices\"];\r\n            for (var i = 0, n = vertices.length; i < n; i++)\r\n                attachment.vertices.push(vertices[i] * scale);\r\n            return attachment;\r\n        } else if (type == spine.AttachmentType.mesh || type == spine.AttachmentType.linkedmesh ||\r\n            type == spine.AttachmentType.weightedmesh || type == spine.AttachmentType.weightedlinkedmesh)\r\n        {\r\n            var vertexCount = map[\"vertexCount\"] || 0;\r\n            if (vertexCount * 2 === map[\"vertices\"].length ||\r\n                map[\"vertices\"].length === map[\"uvs\"].length) {\r\n                //regular mesh\r\n                var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                if (!mesh) return null;\r\n                mesh.path = path;\r\n                color = map[\"color\"];\r\n                if (color) {\r\n                    mesh.r = this.toColor(color, 0);\r\n                    mesh.g = this.toColor(color, 1);\r\n                    mesh.b = this.toColor(color, 2);\r\n                    mesh.a = this.toColor(color, 3);\r\n                }\r\n                mesh.width = (map[\"width\"] || 0) * scale;\r\n                mesh.height = (map[\"height\"] || 0) * scale;\r\n\r\n                var parent = map[\"parent\"];\r\n                if (!parent) {\r\n                    mesh.vertices = this.getFloatArray(map, \"vertices\", scale);\r\n                    mesh.triangles = this.getIntArray(map, \"triangles\");\r\n                    mesh.regionUVs = this.getFloatArray(map, \"uvs\", 1);\r\n                    mesh.updateUVs();\r\n                    mesh.hullLength = (map[\"hull\"] || 0) * 2;\r\n                    if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\r\n                } else {\r\n                    mesh.inheritFFD = !!map[\"ffd\"];\r\n                    this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\r\n                }\r\n                return mesh;\r\n            } else {\r\n                //weighted mesh\r\n                var mesh = this.attachmentLoader.newWeightedMeshAttachment(skin, name, path);\r\n                if (!mesh) return null;\r\n                mesh.path = path;\r\n                color = map[\"color\"];\r\n                if (color) {\r\n                    mesh.r = this.toColor(color, 0);\r\n                    mesh.g = this.toColor(color, 1);\r\n                    mesh.b = this.toColor(color, 2);\r\n                    mesh.a = this.toColor(color, 3);\r\n                }\r\n                mesh.width = (map[\"width\"] || 0) * scale;\r\n                mesh.height = (map[\"height\"] || 0) * scale;\r\n\r\n                var parent = map[\"parent\"];\r\n                if (!parent) {\r\n                    var uvs = this.getFloatArray(map, \"uvs\", 1);\r\n                    var vertices = this.getFloatArray(map, \"vertices\", 1);\r\n                    var weights = [];\r\n                    var bones = [];\r\n                    for (var i = 0, n = vertices.length; i < n;) {\r\n                        var boneCount = vertices[i++] | 0;\r\n                        bones[bones.length] = boneCount;\r\n                        for (var nn = i + boneCount * 4; i < nn;) {\r\n                            bones[bones.length] = vertices[i];\r\n                            weights[weights.length] = vertices[i + 1] * scale;\r\n                            weights[weights.length] = vertices[i + 2] * scale;\r\n                            weights[weights.length] = vertices[i + 3];\r\n                            i += 4;\r\n                        }\r\n                    }\r\n                    mesh.bones = bones;\r\n                    mesh.weights = weights;\r\n                    mesh.triangles = this.getIntArray(map, \"triangles\");\r\n                    mesh.regionUVs = uvs;\r\n                    mesh.updateUVs();\r\n\r\n                    mesh.hullLength = (map[\"hull\"] || 0) * 2;\r\n                    if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\r\n                } else {\r\n                    mesh.inheritFFD = !!map[\"ffd\"];\r\n                    this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\r\n                }\r\n                return mesh;\r\n            }\r\n        }\r\n        throw \"Unknown attachment type: \" + type;\r\n    },\r\n    readAnimation: function (name, map, skeletonData)\r\n    {\r\n        var timelines = [];\r\n        var duration = 0;\r\n\r\n        var slots = map[\"slots\"];\r\n        for (var slotName in slots)\r\n        {\r\n            if (!slots.hasOwnProperty(slotName)) continue;\r\n            var slotMap = slots[slotName];\r\n            var slotIndex = skeletonData.findSlotIndex(slotName);\r\n\r\n            for (var timelineName in slotMap)\r\n            {\r\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\r\n                var values = slotMap[timelineName];\r\n                if (timelineName == \"color\")\r\n                {\r\n                    var timeline = new spine.ColorTimeline(values.length);\r\n                    timeline.slotIndex = slotIndex;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        var color = valueMap[\"color\"];\r\n                        var r = this.toColor(color, 0);\r\n                        var g = this.toColor(color, 1);\r\n                        var b = this.toColor(color, 2);\r\n                        var a = this.toColor(color, 3);\r\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\r\n                        this.readCurve(timeline, frameIndex, valueMap);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\r\n\r\n                } else if (timelineName == \"attachment\")\r\n                {\r\n                    var timeline = new spine.AttachmentTimeline(values.length);\r\n                    timeline.slotIndex = slotIndex;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\r\n                } else\r\n                    throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\r\n            }\r\n        }\r\n\r\n        var bones = map[\"bones\"];\r\n        for (var boneName in bones)\r\n        {\r\n            if (!bones.hasOwnProperty(boneName)) continue;\r\n            var boneIndex = skeletonData.findBoneIndex(boneName);\r\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\r\n            var boneMap = bones[boneName];\r\n\r\n            for (var timelineName in boneMap)\r\n            {\r\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\r\n                var values = boneMap[timelineName];\r\n                if (timelineName == \"rotate\")\r\n                {\r\n                    var timeline = new spine.RotateTimeline(values.length);\r\n                    timeline.boneIndex = boneIndex;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\r\n                        this.readCurve(timeline, frameIndex, valueMap);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\r\n\r\n                } else if (timelineName == \"translate\" || timelineName == \"scale\" || timelineName == \"shear\")\r\n                {\r\n                    var timeline;\r\n                    var timelineScale = 1;\r\n                    if (timelineName == \"scale\") {\r\n                        timeline = new spine.ScaleTimeline(values.length);\r\n                    } else if (timelineName == \"shear\") {\r\n                        timeline = new spine.ShearTimeline(values.length);\r\n                    }\r\n                    else\r\n                    {\r\n                        timeline = new spine.TranslateTimeline(values.length);\r\n                        timelineScale = this.scale;\r\n                    }\r\n                    timeline.boneIndex = boneIndex;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\r\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\r\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\r\n                        this.readCurve(timeline, frameIndex, valueMap);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\r\n\r\n                } else if (timelineName == \"flipX\" || timelineName == \"flipY\")\r\n                {\r\n                    throw \"flipX and flipY are not supported in spine v3: (\" + boneName + \")\";\r\n                } else\r\n                    throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\r\n            }\r\n        }\r\n\r\n        var ikMap = map[\"ik\"];\r\n        for (var ikConstraintName in ikMap)\r\n        {\r\n            if (!ikMap.hasOwnProperty(ikConstraintName)) continue;\r\n            var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);\r\n            var values = ikMap[ikConstraintName];\r\n            var timeline = new spine.IkConstraintTimeline(values.length);\r\n            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);\r\n            var frameIndex = 0;\r\n            for (var i = 0, n = values.length; i < n; i++)\r\n            {\r\n                var valueMap = values[i];\r\n                var mix = valueMap.hasOwnProperty(\"mix\") ? valueMap[\"mix\"] : 1;\r\n                var bendDirection = (!valueMap.hasOwnProperty(\"bendPositive\") || valueMap[\"bendPositive\"]) ? 1 : -1;\r\n                timeline.setFrame(frameIndex, valueMap[\"time\"], mix, bendDirection);\r\n                this.readCurve(timeline, frameIndex, valueMap);\r\n                frameIndex++;\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\r\n        }\r\n\r\n        var transformMap = map[\"transform\"];\r\n        for (var transformConstraintName in transformMap)\r\n        {\r\n            if (!transformMap.hasOwnProperty(transformConstraintName)) continue;\r\n            var transformConstraint = skeletonData.findTransformConstraint(transformConstraintName);\r\n            var values = transformMap[transformConstraintName];\r\n            var timeline = new spine.TransformConstraintTimeline(values.length);\r\n            timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(transformConstraint);\r\n            var frameIndex = 0;\r\n            for (var i = 0, n = values.length; i < n; i++)\r\n            {\r\n                var valueMap = values[i];\r\n                var rotateMix = valueMap.hasOwnProperty(\"rotateMix\") ? valueMap[\"rotateMix\"] : 1;\r\n                var translateMix = valueMap.hasOwnProperty(\"translateMix\") ? valueMap[\"translateMix\"] : 1;\r\n                var scaleMix = valueMap.hasOwnProperty(\"scaleMix\") ? valueMap[\"scaleMix\"] : 1;\r\n                var shearMix = valueMap.hasOwnProperty(\"shearMix\") ? valueMap[\"shearMix\"] : 1;\r\n                timeline.setFrame(frameIndex, valueMap[\"time\"], translateMix, scaleMix, shearMix);\r\n                this.readCurve(timeline, frameIndex, valueMap);\r\n                frameIndex++;\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\r\n        }\r\n\r\n        var ffd = map[\"deform\"] || map[\"ffd\"];\r\n        for (var skinName in ffd)\r\n        {\r\n            var skin = skeletonData.findSkin(skinName);\r\n            var slotMap = ffd[skinName];\r\n            for (slotName in slotMap)\r\n            {\r\n                var slotIndex = skeletonData.findSlotIndex(slotName);\r\n                var meshMap = slotMap[slotName];\r\n                for (var meshName in meshMap)\r\n                {\r\n                    var values = meshMap[meshName];\r\n                    var timeline = new spine.FfdTimeline(values.length);\r\n                    var attachment = skin.getAttachment(slotIndex, meshName);\r\n                    if (!attachment) throw \"FFD attachment not found: \" + meshName;\r\n                    timeline.slotIndex = slotIndex;\r\n                    timeline.attachment = attachment;\r\n\r\n                    var isMesh = attachment.type == spine.AttachmentType.mesh;\r\n                    var vertexCount;\r\n                    if (isMesh)\r\n                        vertexCount = attachment.vertices.length;\r\n                    else\r\n                        vertexCount = attachment.weights.length / 3 * 2;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        var vertices;\r\n                        if (!valueMap[\"vertices\"])\r\n                        {\r\n                            if (isMesh)\r\n                                vertices = attachment.vertices;\r\n                            else\r\n                            {\r\n                                vertices = [];\r\n                                for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\r\n                            }\r\n                        } else {\r\n                            var verticesValue = valueMap[\"vertices\"];\r\n                            vertices = [];\r\n                            for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\r\n                            var start = valueMap[\"offset\"] || 0;\r\n                            var nn = verticesValue.length;\r\n                            if (this.scale == 1)\r\n                            {\r\n                                for (var ii = 0; ii < nn; ii++)\r\n                                    vertices[ii + start] = verticesValue[ii];\r\n                            } else {\r\n                                for (var ii = 0; ii < nn; ii++)\r\n                                    vertices[ii + start] = verticesValue[ii] * this.scale;\r\n                            }\r\n                            if (isMesh)\r\n                            {\r\n                                var meshVertices = attachment.vertices;\r\n                                for (var ii = 0, nn = vertices.length; ii < nn; ii++)\r\n                                    vertices[ii] += meshVertices[ii];\r\n                            }\r\n                        }\r\n\r\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], vertices);\r\n                        this.readCurve(timeline, frameIndex, valueMap);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines[timelines.length] = timeline;\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        var drawOrderValues = map[\"drawOrder\"];\r\n        if (!drawOrderValues) drawOrderValues = map[\"draworder\"];\r\n        if (drawOrderValues)\r\n        {\r\n            var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);\r\n            var slotCount = skeletonData.slots.length;\r\n            var frameIndex = 0;\r\n            for (var i = 0, n = drawOrderValues.length; i < n; i++)\r\n            {\r\n                var drawOrderMap = drawOrderValues[i];\r\n                var drawOrder = null;\r\n                if (drawOrderMap[\"offsets\"])\r\n                {\r\n                    drawOrder = [];\r\n                    drawOrder.length = slotCount;\r\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\r\n                        drawOrder[ii] = -1;\r\n                    var offsets = drawOrderMap[\"offsets\"];\r\n                    var unchanged = [];\r\n                    unchanged.length = slotCount - offsets.length;\r\n                    var originalIndex = 0, unchangedIndex = 0;\r\n                    for (var ii = 0, nn = offsets.length; ii < nn; ii++)\r\n                    {\r\n                        var offsetMap = offsets[ii];\r\n                        var slotIndex = skeletonData.findSlotIndex(offsetMap[\"slot\"]);\r\n                        if (slotIndex == -1) throw \"Slot not found: \" + offsetMap[\"slot\"];\r\n                        // Collect unchanged items.\r\n                        while (originalIndex != slotIndex)\r\n                            unchanged[unchangedIndex++] = originalIndex++;\r\n                        // Set changed items.\r\n                        drawOrder[originalIndex + offsetMap[\"offset\"]] = originalIndex++;\r\n                    }\r\n                    // Collect remaining unchanged items.\r\n                    while (originalIndex < slotCount)\r\n                        unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Fill in unchanged items.\r\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\r\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\r\n                }\r\n                timeline.setFrame(frameIndex++, drawOrderMap[\"time\"], drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        var events = map[\"events\"];\r\n        if (events)\r\n        {\r\n            var timeline = new spine.EventTimeline(events.length);\r\n            var frameIndex = 0;\r\n            for (var i = 0, n = events.length; i < n; i++)\r\n            {\r\n                var eventMap = events[i];\r\n                var eventData = skeletonData.findEvent(eventMap[\"name\"]);\r\n                if (!eventData) throw \"Event not found: \" + eventMap[\"name\"];\r\n                var event = new spine.Event(eventData);\r\n                event.intValue = eventMap.hasOwnProperty(\"int\") ? eventMap[\"int\"] : eventData.intValue;\r\n                event.floatValue = eventMap.hasOwnProperty(\"float\") ? eventMap[\"float\"] : eventData.floatValue;\r\n                event.stringValue = eventMap.hasOwnProperty(\"string\") ? eventMap[\"string\"] : eventData.stringValue;\r\n                timeline.setFrame(frameIndex++, eventMap[\"time\"], event);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\r\n    },\r\n    readCurve: function (timeline, frameIndex, valueMap)\r\n    {\r\n        var curve = valueMap[\"curve\"];\r\n        if (!curve)\r\n            timeline.curves.setLinear(frameIndex);\r\n        else if (curve == \"stepped\")\r\n            timeline.curves.setStepped(frameIndex);\r\n        else if (curve instanceof Array)\r\n            timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\r\n    },\r\n    toColor: function (hexString, colorIndex)\r\n    {\r\n        if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\r\n        return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;\r\n    },\r\n    getFloatArray: function (map, name, scale)\r\n    {\r\n        var list = map[name];\r\n        var values = new spine.Float32Array(list.length);\r\n        var i = 0, n = list.length;\r\n        if (scale == 1)\r\n        {\r\n            for (; i < n; i++)\r\n                values[i] = list[i];\r\n        } else {\r\n            for (; i < n; i++)\r\n                values[i] = list[i] * scale;\r\n        }\r\n        return values;\r\n    },\r\n    getIntArray: function (map, name)\r\n    {\r\n        var list = map[name];\r\n        var values = new spine.Uint16Array(list.length);\r\n        for (var i = 0, n = list.length; i < n; i++)\r\n            values[i] = list[i] | 0;\r\n        return values;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonJsonParser;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./AttachmentTimeline\":10,\"./AttachmentType\":11,\"./BoneData\":13,\"./ColorTimeline\":15,\"./DrawOrderTimeline\":17,\"./Event\":18,\"./EventData\":19,\"./EventTimeline\":20,\"./FfdTimeline\":21,\"./IkConstraintData\":23,\"./IkConstraintTimeline\":24,\"./RotateTimeline\":27,\"./ScaleTimeline\":28,\"./ShearTimeline\":29,\"./SkeletonData\":32,\"./Skin\":34,\"./SlotData\":36,\"./TransformConstraintData\":39,\"./TransformConstraintTimeline\":40,\"./TranslateTimeline\":41}],34:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Skin = function (name)\r\n{\r\n    this.name = name;\r\n    this.attachments = {};\r\n};\r\nspine.Skin.prototype = {\r\n    addAttachment: function (slotIndex, name, attachment)\r\n    {\r\n        this.attachments[slotIndex + \":\" + name] = attachment;\r\n    },\r\n    getAttachment: function (slotIndex, name)\r\n    {\r\n        return this.attachments[slotIndex + \":\" + name];\r\n    },\r\n    _attachAll: function (skeleton, oldSkin)\r\n    {\r\n        for (var key in oldSkin.attachments)\r\n        {\r\n            var colon = key.indexOf(\":\");\r\n            var slotIndex = parseInt(key.substring(0, colon));\r\n            var name = key.substring(colon + 1);\r\n            var slot = skeleton.slots[slotIndex];\r\n            if (slot.attachment && slot.attachment.name == name)\r\n            {\r\n                var attachment = this.getAttachment(slotIndex, name);\r\n                if (attachment) slot.setAttachment(attachment);\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skin;\r\n\r\n\n},{\"../SpineUtil\":44}],35:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Slot = function (slotData, bone)\r\n{\r\n    this.data = slotData;\r\n    this.bone = bone;\r\n    this.setToSetupPose();\r\n};\r\nspine.Slot.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    _attachmentTime: 0,\r\n    attachment: null,\r\n    attachmentVertices: [],\r\n    setAttachment: function (attachment)\r\n    {\r\n        this.attachment = attachment;\r\n        this._attachmentTime = this.bone.skeleton.time;\r\n        this.attachmentVertices.length = 0;\r\n    },\r\n    setAttachmentTime: function (time)\r\n    {\r\n        this._attachmentTime = this.bone.skeleton.time - time;\r\n    },\r\n    getAttachmentTime: function ()\r\n    {\r\n        return this.bone.skeleton.time - this._attachmentTime;\r\n    },\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.r = data.r;\r\n        this.g = data.g;\r\n        this.b = data.b;\r\n        this.a = data.a;\r\n        this.blendMode = data.blendMode;\r\n\r\n        var slotDatas = this.bone.skeleton.data.slots;\r\n        for (var i = 0, n = slotDatas.length; i < n; i++)\r\n        {\r\n            if (slotDatas[i] == data)\r\n            {\r\n                this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Slot;\r\n\r\n\n},{\"../SpineUtil\":44}],36:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.SlotData = function (name, boneData)\r\n{\r\n    this.name = name;\r\n    this.boneData = boneData;\r\n};\r\n\r\nspine.SlotData.PIXI_BLEND_MODE_MAP = {\r\n    'multiply': PIXI.BLEND_MODES.MULTIPLY,\r\n    'screen': PIXI.BLEND_MODES.SCREEN,\r\n    'additive': PIXI.BLEND_MODES.ADD,\r\n    'normal': PIXI.BLEND_MODES.NORMAL\r\n};\r\n\r\nspine.SlotData.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    attachmentName: null,\r\n    blendMode: PIXI.BLEND_MODES.NORMAL\r\n\r\n\r\n};\r\n\r\n\r\nmodule.exports = spine.SlotData;\r\n\r\n\n},{\"../SpineUtil\":44}],37:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.TrackEntry = function ()\r\n{};\r\nspine.TrackEntry.prototype = {\r\n    next: null, previous: null,\r\n    animation: null,\r\n    loop: false,\r\n    delay: 0, time: 0, lastTime: -1, endTime: 0,\r\n    timeScale: 1,\r\n    mixTime: 0, mixDuration: 0, mix: 1,\r\n    onStart: null, onEnd: null, onComplete: null, onEvent: null\r\n};\r\nmodule.exports = spine.TrackEntry;\r\n\r\n\n},{\"../SpineUtil\":44}],38:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nvar tempVec = [0, 0];\r\nspine.TransformConstraint = function (data, skeleton)\r\n{\r\n    this.data = data;\r\n    this.translateMix = data.translateMix;\r\n    this.rotateMix = data.rotateMix;\r\n    this.scaleMix = data.scaleMix;\r\n    this.shearMix = data.shearMix;\r\n    this.offsetX = data.offsetX;\r\n    this.offsetY = data.offsetY;\r\n    this.offsetScaleX = data.offsetScaleX;\r\n    this.offsetScaleY = data.offsetScaleY;\r\n    this.offsetShearY = data.offsetShearY;\r\n\r\n    this.bone = skeleton.findBone(data.bone.name);\r\n    this.target = skeleton.findBone(data.target.name);\r\n};\r\n\r\nspine.TransformConstraint.prototype = {\r\n    update: function() {\r\n        this.apply();\r\n    },\r\n    apply: function ()\r\n    {\r\n        var bm = this.bone.matrix;\r\n        var tm = this.target.matrix;\r\n\r\n        var rotateMix = this.rotateMix;\r\n        if (rotateMix > 0) {\r\n            var a = bm.a, b = bm.c, c = bm.b, d = bm.d;\r\n            var r = Math.atan2(tm.b, tm.a) - Math.atan2(c, a);\r\n            if (r > Math.PI)\r\n                r -= Math.PI*2;\r\n            else if (r < -Math.PI) r += Math.PI*2;\r\n            r *= rotateMix;\r\n            var cos = Math.cos(r), sin = Math.sin(r);\r\n            bm.a = cos * a - sin * c;\r\n            bm.c = cos * b - sin * d;\r\n            bm.b = sin * a + cos * c;\r\n            bm.d = sin * b + cos * d;\r\n        }\r\n\r\n        var scaleMix = this.rotateMix;\r\n        if (scaleMix > 0) {\r\n            var bs = Math.sqrt(bm.a * bm.a + bm.b * bm.b);\r\n            var ts = Math.sqrt(tm.a * tm.a + tm.b * tm.b);\r\n            var s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleX) * scaleMix) / bs : 0;\r\n            bm.a *= s;\r\n            bm.b *= s;\r\n            bs = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\r\n            ts = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\r\n            s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleY) * scaleMix) / bs : 0;\r\n            bm.c *= s;\r\n            bm.d *= s;\r\n        }\r\n\r\n        var shearMix = this.shearMix;\r\n        if (shearMix > 0) {\r\n            var b = bm.c, d = bm.d;\r\n            var by = Math.atan2(d, b);\r\n            var r = Math.atan2(tm.d, tm.c) - Math.atan2(tm.b, target.a) - (by - Math.atan2(bm.b, bm.a));\r\n            if (r > Math.PI)\r\n                r -= Math.PI*2;\r\n            else if (r < -Math.PI) r += Math.PI*2;\r\n            r = by + (r + this.offsetShearY * spine.degRad) * shearMix;\r\n            var s = Math.sqrt(b * b + d * d);\r\n            bm.c = Math.cos(r) * s;\r\n            bm.d = Math.sin(r) * s;\r\n        }\r\n\r\n        var translateMix = this.translateMix;\r\n        if (translateMix > 0) {\r\n            tempVec[0] = this.offsetX;\r\n            tempVec[1] = this.offsetY;\r\n            this.target.localToWorld(tempVec);\r\n            bm.tx += (tempVec[0] - bm.tx) * translateMix;\r\n            bm.ty += (tempVec[1] - bm.ty) * translateMix;\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = spine.TransformConstraint;\r\n\n},{\"../SpineUtil\":44}],39:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.TransformConstraintData = function (name)\r\n{\r\n    this.name = name;\r\n    this.bone = null;\r\n};\r\nspine.TransformConstraintData.prototype = {\r\n    target: null,\r\n    rotateMix: 1,\r\n    translateMix: 1,\r\n    scaleMix: 1,\r\n    shearMix: 1,\r\n    offsetRotation: 0,\r\n    offsetX: 0,\r\n    offsetY: 0,\r\n    offsetScaleX: 0,\r\n    offsetScaleY: 0,\r\n    offsetShearY: 0\r\n};\r\nmodule.exports = spine.TransformConstraintData;\r\n\r\n\n},{\"../SpineUtil\":44}],40:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.TransformConstraintTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, mix, bendDirection, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.TransformConstraintTimeline.prototype = {\r\n    transformConstraintIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 5;\r\n    },\r\n    setFrame: function (frameIndex, time, rotateMix, translateMix, scaleMix, shareMix)\r\n    {\r\n        frameIndex *= 5;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = rotateMix;\r\n        this.frames[frameIndex + 2] = translateMix;\r\n        this.frames[frameIndex + 3] = scaleMix;\r\n        this.frames[frameIndex + 4] = shareMix;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - 5])\r\n        { // Time is after last frame.\r\n            constraint.rotateMix += (frames[i - 3] - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (frames[i - 2] - constraint.translateMix) * alpha;\r\n            constraint.scaleMix += (frames[i - 1] - constraint.scaleMix) * alpha;\r\n            constraint.shearMix += (frames[i] - constraint.shearMix) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frame = spine.Animation.binarySearch(frames, time, 5);\r\n        var frameTime = frames[frame];\r\n        var percent = 1 - (time - frameTime) / (frames[frame + -5/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frame / 5 - 1, percent);\r\n\r\n        var rotate = frames[frame + -4/*PREV_ROTATE_MIX*/];\r\n        var translate = frames[frame + -3/*PREV_TRANSLATE_MIX*/];\r\n        var scale = frames[frame + -2/*PREV_SCALE_MIX*/];\r\n        var shear = frames[frame + -1/*PREV_SHEAR_MIX*/];\r\n        constraint.rotateMix += (rotate + (frames[frame + 1/*ROTATE_MIX*/] - rotate) * percent - constraint.rotateMix) * alpha;\r\n        constraint.translateMix += (translate + (frames[frame + 2/*TRANSLATE_MIX*/] - translate) * percent - constraint.translateMix)\r\n            * alpha;\r\n        constraint.scaleMix += (scale + (frames[frame + 3/*SCALE_MIX*/] - scale) * percent - constraint.scaleMix) * alpha;\r\n        constraint.shearMix += (shear + (frames[frame + 4/*SHEAR_MIX*/] - shear) * percent - constraint.shearMix) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.TransformConstraintTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],41:[function(require,module,exports){\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.TranslateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.TranslateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\r\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;\r\n        bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.TranslateTimeline;\r\n\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./Curves\":16}],42:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.WeightedMeshAttachment = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.WeightedMeshAttachment.prototype = {\r\n    type: spine.AttachmentType.weightedmesh,\r\n    parentMesh: null,\r\n    inheritFFD: false,\r\n    bones: null,\r\n    weights: null,\r\n    uvs: null,\r\n    regionUVs: null,\r\n    triangles: null,\r\n    hullLength: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    edges: null,\r\n    width: 0, height: 0,\r\n    updateUVs: function (u, v, u2, v2, rotate)\r\n    {\r\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\r\n        var n = this.regionUVs.length;\r\n        if (!this.uvs || this.uvs.length != n)\r\n        {\r\n            this.uvs = new spine.Float32Array(n);\r\n        }\r\n        var region = this.rendererObject;\r\n        if (!region) return;\r\n        var texture = region.texture;\r\n        var r = texture._uvs;\r\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\r\n        var x = region.offsetX, y = region.pixiOffsetY;\r\n        for (var i = 0; i < n; i += 2)\r\n        {\r\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\r\n            u = (u * w2 - x) / w1;\r\n            v = (v * h2 - y) / h1;\r\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\r\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\r\n        }\r\n    },\r\n    computeWorldVertices: function (x, y, slot, worldVertices)\r\n    {\r\n        var skeletonBones = slot.bone.skeleton.bones;\r\n        var weights = this.weights;\r\n        var bones = this.bones;\r\n\r\n        var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;\r\n        var wx, wy, vx, vy, weight;\r\n        var m;\r\n        if (!slot.attachmentVertices.length)\r\n        {\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3)\r\n                {\r\n                    m = skeletonBones[bones[v]].matrix;\r\n                    vx = weights[b];\r\n                    vy = weights[b + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\r\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        } else {\r\n            var ffd = slot.attachmentVertices;\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3, f += 2)\r\n                {\r\n                    m = skeletonBones[bones[v]].matrix;\r\n                    vx = weights[b] + ffd[f];\r\n                    vy = weights[b + 1] + ffd[f + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\r\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        }\r\n    },\r\n    applyFFD: function(sourceAttachment) {\r\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\r\n    },\r\n    setParentMesh: function(parentMesh) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh != null) {\r\n            this.bones = parentMesh.bones;\r\n            this.weights = parentMesh.weights;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.WeightedMeshAttachment;\r\n\r\n\n},{\"../SpineUtil\":44,\"./AttachmentType\":11}],43:[function(require,module,exports){\n/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.1\r\n *\r\n * Copyright (c) 2013, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable and\r\n * non-transferable license to install, execute and perform the Spine Runtimes\r\n * Software (the \"Software\") solely for internal use. Without the written\r\n * permission of Esoteric Software (typically granted by licensing Spine), you\r\n * may not (a) modify, translate, adapt or otherwise create derivative works,\r\n * improvements of the Software or develop new applications using the Software\r\n * or (b) remove, delete, alter or obscure any trademarks or any copyright,\r\n * trademark, patent or other intellectual property or proprietary rights\r\n * notices on or in the Software, including any copy thereof. Redistributions\r\n * in binary or source form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\r\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\r\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\r\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.AnimationStateData = require('./AnimationStateData');\r\nspine.AnimationState = require('./AnimationState');\r\nspine.AtlasAttachmentParser = require('./AtlasAttachmentParser');\r\nspine.Atlas = require('./Atlas');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\nspine.AttachmentTimeline = require('./AttachmentTimeline');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.BoneData = require('./BoneData');\r\nspine.Bone = require('./Bone');\r\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\r\nspine.ColorTimeline = require('./ColorTimeline');\r\nspine.Curves = require('./Curves');\r\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\r\nspine.EventData = require('./EventData');\r\nspine.Event = require('./Event');\r\nspine.EventTimeline = require('./EventTimeline');\r\nspine.FfdTimeline = require('./FfdTimeline');\r\nspine.IkConstraintData = require('./IkConstraintData');\r\nspine.IkConstraint = require('./IkConstraint');\r\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\r\nspine.TransformConstraintData = require('./TransformConstraintData');\r\nspine.TransformConstraint = require('./TransformConstraint');\r\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\r\nspine.MeshAttachment = require('./MeshAttachment');\r\nspine.RegionAttachment = require('./RegionAttachment');\r\nspine.RotateTimeline = require('./RotateTimeline');\r\nspine.ScaleTimeline = require('./ScaleTimeline');\r\nspine.ShearTimeline = require('./ShearTimeline');\r\nspine.SkeletonBounds = require('./SkeletonBounds');\r\nspine.SkeletonData = require('./SkeletonData');\r\nspine.Skeleton = require('./Skeleton');\r\nspine.SkeletonJsonParser = require('./SkeletonJsonParser');\r\nspine.Skin = require('./Skin.js');\r\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\r\nspine.SlotData = require('./SlotData');\r\nspine.Slot = require('./Slot');\r\nspine.TrackEntry = require('./TrackEntry');\r\nspine.TranslateTimeline = require('./TranslateTimeline');\r\nmodule.exports = spine;\r\n\n},{\"../SpineUtil\":44,\"./Animation\":2,\"./AnimationState\":3,\"./AnimationStateData\":4,\"./Atlas\":5,\"./AtlasAttachmentParser\":6,\"./AtlasPage\":7,\"./AtlasReader\":8,\"./AtlasRegion\":9,\"./AttachmentTimeline\":10,\"./AttachmentType\":11,\"./Bone\":12,\"./BoneData\":13,\"./BoundingBoxAttachment\":14,\"./ColorTimeline\":15,\"./Curves\":16,\"./DrawOrderTimeline\":17,\"./Event\":18,\"./EventData\":19,\"./EventTimeline\":20,\"./FfdTimeline\":21,\"./IkConstraint\":22,\"./IkConstraintData\":23,\"./IkConstraintTimeline\":24,\"./MeshAttachment\":25,\"./RegionAttachment\":26,\"./RotateTimeline\":27,\"./ScaleTimeline\":28,\"./ShearTimeline\":29,\"./Skeleton\":30,\"./SkeletonBounds\":31,\"./SkeletonData\":32,\"./SkeletonJsonParser\":33,\"./Skin.js\":34,\"./Slot\":35,\"./SlotData\":36,\"./TrackEntry\":37,\"./TransformConstraint\":38,\"./TransformConstraintData\":39,\"./TransformConstraintTimeline\":40,\"./TranslateTimeline\":41,\"./WeightedMeshAttachment\":42}],44:[function(require,module,exports){\nmodule.exports = {\r\n    radDeg: 180 / Math.PI,\r\n    degRad: Math.PI / 180,\r\n    temp: [],\r\n    Float32Array: (typeof(Float32Array) === 'undefined') ? Array : Float32Array,\r\n    Uint16Array: (typeof(Uint16Array) === 'undefined') ? Array : Uint16Array,\r\n    signum: function(x) {\r\n        if (x>0) return 1;\r\n        if (x<0) return -1;\r\n        return 0;\r\n    }\r\n};\r\n\r\n\n},{}],45:[function(require,module,exports){\nvar spine = require('../SpineRuntime');\r\nvar atlasParser = require('../loaders/atlasParser');\r\nvar TransformBase = PIXI.TransformBase || PIXI.TransformManual;\r\n\r\n/* Esoteric Software SPINE wrapper for pixi.js */\r\nspine.Bone.yDown = true;\r\n\r\n/**\r\n * A class that enables the you to import and run your spine animations in pixi.\r\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\r\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\r\n *\r\n * ```js\r\n * var spineAnimation = new PIXI.Spine(spineData);\r\n * ```\r\n *\r\n * @class\r\n * @extends Container\r\n * @memberof PIXI.spine\r\n * @param spineData {object} The spine data loaded from a spine atlas.\r\n */\r\nfunction Spine(spineData)\r\n{\r\n    PIXI.Container.call(this);\r\n\r\n    if (!spineData)\r\n    {\r\n        throw new Error('The spineData param is required.');\r\n    }\r\n\r\n    if ((typeof spineData) === \"string\")\r\n    {\r\n        throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\r\n    }\r\n\r\n    /**\r\n     * The spineData object\r\n     *\r\n     * @member {object}\r\n     */\r\n    this.spineData = spineData;\r\n\r\n    /**\r\n     * A spine Skeleton object\r\n     *\r\n     * @member {object}\r\n     */\r\n    this.skeleton = new spine.Skeleton(spineData);\r\n    this.skeleton.updateWorldTransform();\r\n\r\n    /**\r\n     * A spine AnimationStateData object created from the spine data passed in the constructor\r\n     *\r\n     * @member {object}\r\n     */\r\n    this.stateData = new spine.AnimationStateData(spineData);\r\n\r\n    /**\r\n     * A spine AnimationState object created from the spine AnimationStateData object\r\n     *\r\n     * @member {object}\r\n     */\r\n    this.state = new spine.AnimationState(this.stateData);\r\n\r\n    /**\r\n     * An array of containers\r\n     *\r\n     * @member {Container[]}\r\n     */\r\n    this.slotContainers = [];\r\n\r\n    for (var i = 0, n = this.skeleton.slots.length; i < n; i++)\r\n    {\r\n        var slot = this.skeleton.slots[i];\r\n        var attachment = slot.attachment;\r\n        var slotContainer = new PIXI.Container();\r\n        this.slotContainers.push(slotContainer);\r\n        this.addChild(slotContainer);\r\n\r\n        if (attachment instanceof spine.RegionAttachment)\r\n        {\r\n            var spriteName = attachment.rendererObject.name;\r\n            var sprite = this.createSprite(slot, attachment);\r\n            slot.currentSprite = sprite;\r\n            slot.currentSpriteName = spriteName;\r\n            slotContainer.addChild(sprite);\r\n        }\r\n        else if (attachment instanceof spine.MeshAttachment)\r\n        {\r\n            var mesh = this.createMesh(slot, attachment);\r\n            slot.currentMesh = mesh;\r\n            slot.currentMeshName = attachment.name;\r\n            slotContainer.addChild(mesh);\r\n        }\r\n        else\r\n        {\r\n            continue;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Should the Spine object update its transforms\r\n     *\r\n     * @member {boolean}\r\n     */\r\n    this.autoUpdate = true;\r\n\r\n    /**\r\n     * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\r\n     *\r\n     * @member {number}\r\n     * @memberof PIXI.spine.Spine#\r\n     */\r\n    this.tintRgb = new Float32Array([1, 1, 1]);\r\n}\r\n\r\nSpine.fromAtlas = function(resourceName) {\r\n    var skeletonData = atlasParser.AnimCache[resourceName];\r\n\r\n    if (!skeletonData)\r\n    {\r\n        throw new Error('Spine data \"' + resourceName + '\" does not exist in the animation cache');\r\n    }\r\n\r\n    return new Spine(skeletonData);\r\n}\r\n\r\nSpine.prototype = Object.create(PIXI.Container.prototype);\r\nSpine.prototype.constructor = Spine;\r\nmodule.exports = Spine;\r\n\r\nSpine.globalAutoUpdate = true;\r\n\r\nObject.defineProperties(Spine.prototype, {\r\n    /**\r\n     * If this flag is set to true, the spine animation will be autoupdated every time\r\n     * the object id drawn. The down side of this approach is that the delta time is\r\n     * automatically calculated and you could miss out on cool effects like slow motion,\r\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\r\n     * autoupdate enabled but are harder to achieve.\r\n     *\r\n     * @member {boolean}\r\n     * @memberof PIXI.spine.Spine#\r\n     * @default true\r\n     */\r\n    autoUpdate: {\r\n        get: function ()\r\n        {\r\n            return (this.updateTransform === Spine.prototype.autoUpdateTransform);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\r\n        }\r\n    },\r\n    /**\r\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\r\n     *\r\n     * @member {number}\r\n     * @memberof PIXI.spine.Spine#\r\n     * @default 0xFFFFFF\r\n     */\r\n    tint: {\r\n        get: function() {\r\n            return PIXI.utils.rgb2hex(this.tintRgb);\r\n        },\r\n        set: function(value) {\r\n            this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb);\r\n        }\r\n    }\r\n});\r\n\r\nvar tempRgb = [0, 0, 0];\r\n\r\n/**\r\n * Update the spine skeleton and its animations by delta time (dt)\r\n *\r\n * @param dt {number} Delta time. Time by which the animation should be updated\r\n */\r\nSpine.prototype.update = function (dt)\r\n{\r\n    this.state.update(dt);\r\n    this.state.apply(this.skeleton);\r\n    this.skeleton.updateWorldTransform();\r\n\r\n    var drawOrder = this.skeleton.drawOrder;\r\n    var slots = this.skeleton.slots;\r\n\r\n    for (var i = 0, n = drawOrder.length; i < n; i++)\r\n    {\r\n        this.children[i] = this.slotContainers[drawOrder[i]];\r\n    }\r\n\r\n    var r0 = this.tintRgb[0];\r\n    var g0 = this.tintRgb[1];\r\n    var b0 = this.tintRgb[2];\r\n\r\n    for (i = 0, n = slots.length; i < n; i++)\r\n    {\r\n        var slot = slots[i];\r\n        var attachment = slot.attachment;\r\n        var slotContainer = this.slotContainers[i];\r\n\r\n        if (!attachment)\r\n        {\r\n            slotContainer.visible = false;\r\n            continue;\r\n        }\r\n\r\n        var type = attachment.type;\r\n        if (type === spine.AttachmentType.region)\r\n        {\r\n            if (attachment.rendererObject)\r\n            {\r\n                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name)\r\n                {\r\n                    var spriteName = attachment.rendererObject.name;\r\n                    if (slot.currentSprite !== undefined)\r\n                    {\r\n                        slot.currentSprite.visible = false;\r\n                    }\r\n                    slot.sprites = slot.sprites || {};\r\n                    if (slot.sprites[spriteName] !== undefined)\r\n                    {\r\n                        slot.sprites[spriteName].visible = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        var sprite = this.createSprite(slot, attachment);\r\n                        slotContainer.addChild(sprite);\r\n                    }\r\n                    slot.currentSprite = slot.sprites[spriteName];\r\n                    slot.currentSpriteName = spriteName;\r\n                }\r\n            }\r\n\r\n            if (slotContainer.transform ) {\r\n                var transform = slotContainer.transform;\r\n                var lt;\r\n                if (slotContainer.transform.matrix2d) {\r\n                    //gameofbombs pixi fork\r\n                    lt = transform.matrix2d;\r\n                    transform._dirtyVersion++;\r\n                    transform.version = transform._dirtyVersion;\r\n                    transform.isStatic = true;\r\n                    transform.operMode = 0;\r\n                } else {\r\n                    if (TransformBase) {\r\n                        //PIXI v4.0\r\n                        if (transform.position) {\r\n                            transform = new PIXI.TransformBase();\r\n                            slotContainer.transform = transform;\r\n                        }\r\n                        lt = transform.localTransform;\r\n                    } else {\r\n                        //PIXI v4.0rc\r\n                        if (!transform._dirtyLocal) {\r\n                            transform = new PIXI.TransformStatic();\r\n                            slotContainer.transform = transform;\r\n                        }\r\n                        lt = transform.localTransform;\r\n                        transform._dirtyParentVersion = -1;\r\n                        transform._dirtyLocal = 1;\r\n                        transform._versionLocal = 1;\r\n                    }\r\n                }\r\n                slot.bone.matrix.copy(lt);\r\n                lt.tx += slot.bone.skeleton.x;\r\n                lt.ty += slot.bone.skeleton.y;\r\n            } else {\r\n                //PIXI v3\r\n                var lt = slotContainer.localTransform || new PIXI.Matrix();\r\n                slot.bone.matrix.copy(lt);\r\n                lt.tx += slot.bone.skeleton.x;\r\n                lt.ty += slot.bone.skeleton.y;\r\n                slotContainer.localTransform = lt;\r\n                slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\r\n            }\r\n            tempRgb[0] = r0 * slot.r * attachment.r;\r\n            tempRgb[1] = g0 * slot.g * attachment.g;\r\n            tempRgb[2] = b0 * slot.b * attachment.b;\r\n            slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\r\n            slot.currentSprite.blendMode = slot.blendMode;\r\n        }\r\n        else if (type === spine.AttachmentType.skinnedmesh || type === spine.AttachmentType.mesh || type === spine.AttachmentType.linkedmesh)\r\n        {\r\n            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name)\r\n            {\r\n                var meshName = attachment.name;\r\n                if (slot.currentMesh !== undefined)\r\n                {\r\n                    slot.currentMesh.visible = false;\r\n                }\r\n\r\n                slot.meshes = slot.meshes || {};\r\n\r\n                if (slot.meshes[meshName] !== undefined)\r\n                {\r\n                    slot.meshes[meshName].visible = true;\r\n                }\r\n                else\r\n                {\r\n                    var mesh = this.createMesh(slot, attachment);\r\n                    slotContainer.addChild(mesh);\r\n                }\r\n\r\n                slot.currentMesh = slot.meshes[meshName];\r\n                slot.currentMeshName = meshName;\r\n            }\r\n            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);\r\n            if (PIXI.VERSION[0] !== '3') {\r\n                // PIXI version 4\r\n                slot.currentMesh.dirty = true;\r\n                //only for PIXI v4\r\n                var tintRgb = slot.currentMesh.tintRgb;\r\n                tintRgb[0] = r0 * slot.r * attachment.r;\r\n                tintRgb[1] = g0 * slot.g * attachment.g;\r\n                tintRgb[2] = b0 * slot.b * attachment.b;\r\n            }\r\n            slot.currentMesh.blendMode = slot.blendMode;\r\n        }\r\n        else\r\n        {\r\n            slotContainer.visible = false;\r\n            continue;\r\n        }\r\n        slotContainer.visible = true;\r\n\r\n        slotContainer.alpha = slot.a;\r\n    }\r\n};\r\n\r\n/**\r\n * When autoupdate is set to yes this function is used as pixi's updateTransform function\r\n *\r\n * @private\r\n */\r\nSpine.prototype.autoUpdateTransform = function ()\r\n{\r\n    if (Spine.globalAutoUpdate) {\r\n        this.lastTime = this.lastTime || Date.now();\r\n        var timeDelta = (Date.now() - this.lastTime) * 0.001;\r\n        this.lastTime = Date.now();\r\n        this.update(timeDelta);\r\n    } else {\r\n        this.lastTime = 0;\r\n    }\r\n\r\n    PIXI.Container.prototype.updateTransform.call(this);\r\n};\r\n\r\n/**\r\n * Create a new sprite to be used with spine.RegionAttachment\r\n *\r\n * @param slot {spine.Slot} The slot to which the attachment is parented\r\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n * @private\r\n */\r\nSpine.prototype.createSprite = function (slot, attachment)\r\n{\r\n    var descriptor = attachment.rendererObject;\r\n    var texture = descriptor.texture;\r\n    var sprite = new PIXI.Sprite(texture);\r\n    sprite.scale.x = attachment.scaleX * attachment.width / descriptor.originalWidth;\r\n    sprite.scale.y = - attachment.scaleY * attachment.height / descriptor.originalHeight;\r\n    sprite.rotation = attachment.rotation * spine.degRad;\r\n    sprite.anchor.x = 0.5;\r\n    sprite.anchor.y = 0.5;\r\n    sprite.position.x = attachment.x;\r\n    sprite.position.y = attachment.y;\r\n    sprite.alpha = attachment.a;\r\n\r\n    slot.sprites = slot.sprites || {};\r\n    slot.sprites[descriptor.name] = sprite;\r\n    return sprite;\r\n};\r\n\r\n/**\r\n * Creates a Strip from the spine data\r\n * @param slot {spine.Slot} The slot to which the attachment is parented\r\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n * @private\r\n */\r\nSpine.prototype.createMesh = function (slot, attachment)\r\n{\r\n    var descriptor = attachment.rendererObject;\r\n    var baseTexture = descriptor.page.rendererObject;\r\n    var texture = new PIXI.Texture(baseTexture);\r\n\r\n    var strip = new PIXI.mesh.Mesh(\r\n        texture,\r\n        new Float32Array(attachment.uvs.length),\r\n        new Float32Array(attachment.uvs),\r\n        new Uint16Array(attachment.triangles),\r\n        PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\r\n\r\n    strip.canvasPadding = 1.5;\r\n\r\n    strip.alpha = attachment.a;\r\n\r\n    slot.meshes = slot.meshes || {};\r\n    slot.meshes[attachment.name] = strip;\r\n\r\n    return strip;\r\n};\r\n\r\n/**\r\n * Changes texture in attachment in specific slot.\r\n *\r\n * PIXI runtime feature, it was made to satisfy our users.\r\n *\r\n * @param slotName {string}\r\n * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n * @returns {boolean} Success flag\r\n */\r\nSpine.prototype.hackTextureBySlotIndex = function(slotIndex, texture, size) {\r\n    var slot = this.skeleton.slots[slotIndex];\r\n    if (!slot) {\r\n        return false;\r\n    }\r\n    var attachment = slot.attachment;\r\n    if (!attachment || !attachment.hackRegion) {\r\n        return false;\r\n    }\r\n    var region = null;\r\n    if (texture) {\r\n        region = new spine.AtlasRegion();\r\n        region.texture = texture;\r\n        region.size = size;\r\n    }\r\n\r\n    attachment.hackRegion(region);\r\n    var descriptor = attachment.rendererObject;\r\n    if (slot.currentSprite) {\r\n        var sprite = slot.currentSprite;\r\n        sprite.texture = descriptor.texture;\r\n        sprite.scale.x = attachment.width / descriptor.originalWidth;\r\n        sprite.scale.y = - attachment.height / descriptor.originalHeight;\r\n    }\r\n    if (slot.currentMesh) {\r\n        var mesh = slot.currentMesh;\r\n        mesh.texture = descriptor.texture;\r\n        for (var i = 0; i < attachment.uvs.length; i++) {\r\n            mesh.uvs[i] = attachment.uvs[i];\r\n        }\r\n        if (PIXI.VERSION[0] !== '3') {\r\n            // PIXI version 4\r\n            mesh.indexDirty = true;\r\n        } else {\r\n            // PIXI version 3\r\n            mesh.dirty = true;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\n/**\r\n * Changes texture in attachment in specific slot.\r\n *\r\n * PIXI runtime feature, it was made to satisfy our users.\r\n *\r\n * @param slotName {string}\r\n * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n * @returns {boolean} Success flag\r\n */\r\nSpine.prototype.hackTextureBySlotName = function(slotName, texture, size) {\r\n    var index = this.skeleton.findSlotIndex(slotName);\r\n    if (index == -1) {\r\n        return false;\r\n    }\r\n    return this.hackTextureBySlotIndex(index,texture, size);\r\n};\r\n\r\nfunction SlotContainerUpdateTransformV3()\r\n{\r\n    var pt = this.parent.worldTransform;\r\n    var wt = this.worldTransform;\r\n    var lt = this.localTransform;\r\n    wt.a  = lt.a  * pt.a + lt.b  * pt.c;\r\n    wt.b  = lt.a  * pt.b + lt.b  * pt.d;\r\n    wt.c  = lt.c  * pt.a + lt.d  * pt.c;\r\n    wt.d  = lt.c  * pt.b + lt.d  * pt.d;\r\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\r\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\r\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\r\n    this._currentBounds = null;\r\n};\r\n\n},{\"../SpineRuntime\":43,\"../loaders/atlasParser\":47}],46:[function(require,module,exports){\n/**\r\n * @file        Spine resource loader\r\n * @author      Ivan Popelyshev <ivan.popelyshev@gmail.com>\r\n * @copyright   2013-2015 GoodBoyDigital\r\n * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace PIXI.loaders\r\n */\r\n\r\nvar atlasParser = require('./atlasParser');\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\r\nPIXI.loader.use(atlasParser());\r\n\n},{\"./atlasParser\":47}],47:[function(require,module,exports){\nvar Resource = PIXI.loaders.Resource,\r\n    spine = require('../SpineRuntime'),\r\n    imageLoaderAdapter = require('./imageLoaderAdapter');\r\n\r\nvar atlasParser = module.exports = function () {\r\n    return function (resource, next) {\r\n        // skip if no data, its not json, or it isn't atlas data\r\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\r\n            return next();\r\n        }\r\n\r\n        var metadataAtlas = resource.metadata ? resource.metadata.spineAtlas: null;\r\n        if (metadataAtlas === false) {\r\n            return next();\r\n        }\r\n        if (metadataAtlas && metadataAtlas.pages) {\r\n            //its an atlas!\r\n            var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(metadataAtlas));\r\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n            resource.spineData = skeletonData;\r\n            resource.spineAtlas = metadataAtlas;\r\n            if (atlasParser.enableCaching) {\r\n                atlasParser.AnimCache[resource.name] = resource.spineData;\r\n            }\r\n\r\n            return next();\r\n        }\r\n\r\n        var metadataAtlasSuffix = '.atlas';\r\n        if (resource.metadata && resource.metadata.spineAtlasSuffix) {\r\n            metadataAtlasSuffix = resource.metadata.spineAtlasSuffix;\r\n        }\r\n\r\n        /**\r\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n         * have the same name\r\n         */\r\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;\r\n        //remove the baseUrl\r\n        atlasPath = atlasPath.replace(this.baseUrl, '');\r\n\r\n        var atlasOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            xhrType: Resource.XHR_RESPONSE_TYPE.TEXT,\r\n            metadata: resource.metadata ? resource.metadata.spineMetadata : null\r\n        };\r\n        var imageOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            metadata: resource.metadata ? resource.metadata.imageMetadata: null\r\n        };\r\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n        //remove the baseUrl\r\n        baseUrl = baseUrl.replace(this.baseUrl, '');\r\n\r\n        var adapter = imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\r\n\r\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (res) {\r\n            new spine.Atlas(this.xhr.responseText, adapter, function(spineAtlas) {\r\n                var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(spineAtlas));\r\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n                resource.spineData = skeletonData;\r\n                resource.spineAtlas = spineAtlas;\r\n                if (atlasParser.enableCaching) {\r\n                    atlasParser.AnimCache[resource.name] = resource.spineData;\r\n                }\r\n\r\n                next();\r\n            });\r\n        });\r\n    };\r\n};\r\n\r\natlasParser.AnimCache = {};\r\natlasParser.enableCaching = false;\r\n\n},{\"../SpineRuntime\":43,\"./imageLoaderAdapter\":48}],48:[function(require,module,exports){\nvar spine = require('../SpineRuntime');\r\n\r\nmodule.exports = function (loader, namePrefix, baseUrl, imageOptions) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line, callback) {\r\n        var name = namePrefix + line;\r\n        var url = baseUrl + line;\r\n        loader.add(name, url, imageOptions, function(resource) {\r\n            callback(resource.texture.baseTexture);\r\n        });\r\n    }\r\n};\r\n\n},{\"../SpineRuntime\":43}],49:[function(require,module,exports){\nmodule.exports = {\r\n    atlasParser: require('./atlasParser'),\r\n    Loader: require('./Loader'),\r\n    syncImageLoaderAdapter: require('./syncImageLoaderAdapter'),\r\n    imageLoaderAdapter: require('./imageLoaderAdapter')\r\n};\r\n\n},{\"./Loader\":46,\"./atlasParser\":47,\"./imageLoaderAdapter\":48,\"./syncImageLoaderAdapter\":50}],50:[function(require,module,exports){\nvar spine = require('../SpineRuntime');\r\n\r\nmodule.exports = function (baseUrl, crossOrigin) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line, callback) {\r\n        callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\r\n    }\r\n};\r\n\n},{\"../SpineRuntime\":43}]},{},[1])(1)\n});\n\n","var spine = require('../SpineUtil');\r\nspine.Animation = function (name, timelines, duration)\r\n{\r\n    this.name = name;\r\n    this.timelines = timelines;\r\n    this.duration = duration;\r\n};\r\nspine.Animation.prototype = {\r\n    apply: function (skeleton, lastTime, time, loop, events)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\r\n    },\r\n    mix: function (skeleton, lastTime, time, loop, events, alpha)\r\n    {\r\n        if (loop && this.duration != 0)\r\n        {\r\n            time %= this.duration;\r\n            lastTime %= this.duration;\r\n        }\r\n        var timelines = this.timelines;\r\n        for (var i = 0, n = timelines.length; i < n; i++)\r\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\r\n    }\r\n};\r\nspine.Animation.binarySearch = function (values, target, step)\r\n{\r\n    var low = 0;\r\n    var high = Math.floor(values.length / step) - 2;\r\n    if (!high) return step;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[(current + 1) * step] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return (low + 1) * step;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.binarySearch1 = function (values, target)\r\n{\r\n    var low = 0;\r\n    var high = values.length - 2;\r\n    if (!high) return 1;\r\n    var current = high >>> 1;\r\n    while (true)\r\n    {\r\n        if (values[current + 1] <= target)\r\n            low = current + 1;\r\n        else\r\n            high = current;\r\n        if (low == high) return low + 1;\r\n        current = (low + high) >>> 1;\r\n    }\r\n};\r\nspine.Animation.linearSearch = function (values, target, step)\r\n{\r\n    for (var i = 0, last = values.length - step; i <= last; i += step)\r\n        if (values[i] > target) return i;\r\n    return -1;\r\n};\r\nmodule.exports = spine.Animation;\r\n","var spine = require('../SpineUtil');\r\nspine.TrackEntry = require('./TrackEntry');\r\nspine.AnimationState = function (stateData)\r\n{\r\n    this.data = stateData;\r\n    this.tracks = [];\r\n    this.events = [];\r\n};\r\nspine.AnimationState.prototype = {\r\n    onStart: null,\r\n    onEnd: null,\r\n    onComplete: null,\r\n    onEvent: null,\r\n    timeScale: 1,\r\n    update: function (delta)\r\n    {\r\n        delta *= this.timeScale;\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            current.time += delta * current.timeScale;\r\n            if (current.previous)\r\n            {\r\n                var previousDelta = delta * current.previous.timeScale;\r\n                current.previous.time += previousDelta;\r\n                current.mixTime += previousDelta;\r\n            }\r\n\r\n            var next = current.next;\r\n            if (next)\r\n            {\r\n                next.time = current.lastTime - next.delay;\r\n                if (next.time >= 0) this.setCurrent(i, next);\r\n            } else {\r\n                // End non-looping animation when it reaches its end time and there is no next entry.\r\n                if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);\r\n            }\r\n        }\r\n    },\r\n    apply: function (skeleton)\r\n    {\r\n        skeleton.resetDrawOrder();\r\n\r\n        for (var i = 0; i < this.tracks.length; i++)\r\n        {\r\n            var current = this.tracks[i];\r\n            if (!current) continue;\r\n\r\n            this.events.length = 0;\r\n\r\n            var time = current.time;\r\n            var lastTime = current.lastTime;\r\n            var endTime = current.endTime;\r\n            var loop = current.loop;\r\n            if (!loop && time > endTime) time = endTime;\r\n\r\n            var previous = current.previous;\r\n            if (!previous)\r\n            {\r\n                if (current.mix == 1)\r\n                    current.animation.apply(skeleton, current.lastTime, time, loop, this.events);\r\n                else\r\n                    current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);\r\n            } else {\r\n                var previousTime = previous.time;\r\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\r\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\r\n\r\n                var alpha = current.mixTime / current.mixDuration * current.mix;\r\n                if (alpha >= 1)\r\n                {\r\n                    alpha = 1;\r\n                    current.previous = null;\r\n                }\r\n                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);\r\n            }\r\n\r\n            for (var ii = 0, nn = this.events.length; ii < nn; ii++)\r\n            {\r\n                var event = this.events[ii];\r\n                if (current.onEvent) current.onEvent(i, event);\r\n                if (this.onEvent) this.onEvent(i, event);\r\n            }\r\n\r\n            // Check if completed the animation or a loop iteration.\r\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime))\r\n            {\r\n                var count = Math.floor(time / endTime);\r\n                if (current.onComplete) current.onComplete(i, count);\r\n                if (this.onComplete) this.onComplete(i, count);\r\n            }\r\n\r\n            current.lastTime = current.time;\r\n        }\r\n    },\r\n    clearTracks: function ()\r\n    {\r\n        for (var i = 0, n = this.tracks.length; i < n; i++)\r\n            this.clearTrack(i);\r\n        this.tracks.length = 0;\r\n    },\r\n    clearTrack: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return;\r\n        var current = this.tracks[trackIndex];\r\n        if (!current) return;\r\n\r\n        if (current.onEnd) current.onEnd(trackIndex);\r\n        if (this.onEnd) this.onEnd(trackIndex);\r\n\r\n        this.tracks[trackIndex] = null;\r\n    },\r\n    _expandToIndex: function (index)\r\n    {\r\n        if (index < this.tracks.length) return this.tracks[index];\r\n        while (index >= this.tracks.length)\r\n            this.tracks.push(null);\r\n        return null;\r\n    },\r\n    setCurrent: function (index, entry)\r\n    {\r\n        var current = this._expandToIndex(index);\r\n        if (current)\r\n        {\r\n            var previous = current.previous;\r\n            current.previous = null;\r\n\r\n            if (current.onEnd) current.onEnd(index);\r\n            if (this.onEnd) this.onEnd(index);\r\n\r\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\r\n            if (entry.mixDuration > 0)\r\n            {\r\n                entry.mixTime = 0;\r\n                // If a mix is in progress, mix from the closest animation.\r\n                if (previous && current.mixTime / current.mixDuration < 0.5)\r\n                    entry.previous = previous;\r\n                else\r\n                    entry.previous = current;\r\n            }\r\n        }\r\n\r\n        this.tracks[index] = entry;\r\n\r\n        if (entry.onStart) entry.onStart(index);\r\n        if (this.onStart) this.onStart(index);\r\n    },\r\n    setAnimationByName: function (trackIndex, animationName, loop)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.setAnimation(trackIndex, animation, loop);\r\n    },\r\n    /** Set the current animation. Any queued animations are cleared. */\r\n    setAnimation: function (trackIndex, animation, loop)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n        this.setCurrent(trackIndex, entry);\r\n        return entry;\r\n    },\r\n    addAnimationByName: function (trackIndex, animationName, loop, delay)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        if (!animation) throw \"Animation not found: \" + animationName;\r\n        return this.addAnimation(trackIndex, animation, loop, delay);\r\n    },\r\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\r\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\r\n    addAnimation: function (trackIndex, animation, loop, delay)\r\n    {\r\n        var entry = new spine.TrackEntry();\r\n        entry.animation = animation;\r\n        entry.loop = loop;\r\n        entry.endTime = animation.duration;\r\n\r\n        var last = this._expandToIndex(trackIndex);\r\n        if (last)\r\n        {\r\n            while (last.next)\r\n                last = last.next;\r\n            last.next = entry;\r\n        } else\r\n            this.tracks[trackIndex] = entry;\r\n\r\n        if (delay <= 0)\r\n        {\r\n            if (last)\r\n                delay += last.endTime - this.data.getMix(last.animation, animation);\r\n            else\r\n                delay = 0;\r\n        }\r\n        entry.delay = delay;\r\n\r\n        return entry;\r\n    },\r\n    /**\r\n     * Returns true if animation exists in skeleton data\r\n     * @param animationName\r\n     * @returns {boolean}\r\n     */\r\n    hasAnimationByName: function (animationName)\r\n    {\r\n        var animation = this.data.skeletonData.findAnimation(animationName);\r\n        return animation !== null;\r\n    },\r\n    /** May be null. */\r\n    getCurrent: function (trackIndex)\r\n    {\r\n        if (trackIndex >= this.tracks.length) return null;\r\n        return this.tracks[trackIndex];\r\n    }\r\n};\r\nmodule.exports = spine.AnimationState;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AnimationStateData = function (skeletonData)\r\n{\r\n    this.skeletonData = skeletonData;\r\n    this.animationToMixTime = {};\r\n};\r\nspine.AnimationStateData.prototype = {\r\n    defaultMix: 0,\r\n    setMixByName: function (fromName, toName, duration)\r\n    {\r\n        var from = this.skeletonData.findAnimation(fromName);\r\n        if (!from) throw \"Animation not found: \" + fromName;\r\n        var to = this.skeletonData.findAnimation(toName);\r\n        if (!to) throw \"Animation not found: \" + toName;\r\n        this.setMix(from, to, duration);\r\n    },\r\n    setMix: function (from, to, duration)\r\n    {\r\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\r\n    },\r\n    getMix: function (from, to)\r\n    {\r\n        var key = from.name + \":\" + to.name;\r\n        return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;\r\n    }\r\n};\r\nmodule.exports = spine.AnimationStateData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\nvar syncImageLoaderAdapter = require('../loaders/syncImageLoaderAdapter.js')\r\n\r\nspine.Atlas = function(atlasText, loaderFunction, callback) {\r\n    this.pages = [];\r\n    this.regions = [];\r\n    if (typeof atlasText === \"string\") {\r\n        this.addSpineAtlas.call(this, atlasText, loaderFunction, callback);\r\n    }\r\n};\r\n\r\nspine.Atlas.prototype = {\r\n    addTexture: function(name, texture) {\r\n        var pages = this.pages;\r\n        var page = null;\r\n        for (var i=0;i<pages.length;i++) {\r\n            if (pages[i].rendererObject === texture.baseTexture) {\r\n                page = pages[i];\r\n                break;\r\n            }\r\n        }\r\n        if (page === null) {\r\n            page = new spine.AtlasPage();\r\n            page.name = 'texturePage';\r\n            var baseTexture = texture.baseTexture;\r\n            page.width = baseTexture.realWidth;\r\n            page.height = baseTexture.realHeight;\r\n            page.rendererObject = baseTexture;\r\n            //those fields are not relevant in Pixi\r\n            page.format = 'RGBA8888';\r\n            page.minFilter = page.magFilter = \"Nearest\";\r\n            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n            pages.push(page);\r\n        }\r\n        var region = new spine.AtlasRegion();\r\n        region.name = name;\r\n        region.page = page;\r\n        region.texture = texture;\r\n        region.index = -1;\r\n        this.regions.push(region);\r\n        return region;\r\n    },\r\n    addTextureHash: function(textures, stripExtension) {\r\n        for (var key in textures) {\r\n            if (textures.hasOwnProperty(key)) {\r\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\r\n            }\r\n        }\r\n    },\r\n    addSpineAtlas: function (atlasText, loaderFunction, callback)\r\n    {\r\n        //TODO: remove this legacy later\r\n        if (typeof loaderFunction !== \"function\") {\r\n            //old syntax\r\n            var baseUrl = loaderFunction;\r\n            var crossOrigin = callback;\r\n            loaderFunction = syncImageLoaderAdapter(baseUrl, crossOrigin);\r\n            callback = null;\r\n        }\r\n\r\n        this.texturesLoading = 0;\r\n\r\n        var self = this;\r\n\r\n        var reader = new spine.AtlasReader(atlasText);\r\n        var tuple = [];\r\n        tuple.length = 4;\r\n        var page = null;\r\n\r\n        iterateParser();\r\n\r\n        function iterateParser() {\r\n            while (true) {\r\n                var line = reader.readLine();\r\n                if (line === null) {\r\n                    return callback && callback(self);\r\n                }\r\n                line = reader.trim(line);\r\n                if (!line.length)\r\n                    page = null;\r\n                else if (!page) {\r\n                    page = new spine.AtlasPage();\r\n                    page.name = line;\r\n\r\n                    if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\r\n                        page.width = parseInt(tuple[0]);\r\n                        page.height = parseInt(tuple[1]);\r\n                        reader.readTuple(tuple);\r\n                    } else {\r\n                        //old format, detect width and height by texture\r\n                    }\r\n                    page.format = spine.Atlas.Format[tuple[0]];\r\n\r\n                    reader.readTuple(tuple);\r\n                    page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\r\n                    page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\r\n\r\n                    var direction = reader.readValue();\r\n                    page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n                    page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\r\n                    if (direction == \"x\")\r\n                        page.uWrap = spine.Atlas.TextureWrap.repeat;\r\n                    else if (direction == \"y\")\r\n                        page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n                    else if (direction == \"xy\")\r\n                        page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\r\n\r\n                    // @ivanpopelyshev: I so want to use generators and \"yield()\" here, or at least promises\r\n                    loaderFunction(line, function (texture) {\r\n                        page.rendererObject = texture;\r\n                        if (!texture.hasLoaded) {\r\n                            texture.width = page.width;\r\n                            texture.height = page.height;\r\n                        }\r\n                        self.pages.push(page);\r\n                        if (!page.width || !page.height) {\r\n                            page.width = texture.realWidth;\r\n                            page.height = texture.realHeight;\r\n                            if (!page.width || !page.height) {\r\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\r\n                            }\r\n                        }\r\n                        iterateParser();\r\n                    });\r\n                    break;\r\n                } else {\r\n                    var region = new spine.AtlasRegion();\r\n                    region.name = line;\r\n                    region.page = page;\r\n\r\n                    var rotate = reader.readValue() === \"true\" ? 6 : 0;\r\n\r\n                    reader.readTuple(tuple);\r\n                    var x = parseInt(tuple[0]);\r\n                    var y = parseInt(tuple[1]);\r\n\r\n                    reader.readTuple(tuple);\r\n                    var width = parseInt(tuple[0]);\r\n                    var height = parseInt(tuple[1]);\r\n\r\n                    var resolution = page.rendererObject.resolution;\r\n                    x /= resolution;\r\n                    y /= resolution;\r\n                    width /= resolution;\r\n                    height /= resolution;\r\n\r\n                    var frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\r\n\r\n                    if (reader.readTuple(tuple) == 4) { // split is optional\r\n                        region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                        if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\r\n                            region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\r\n\r\n                            reader.readTuple(tuple);\r\n                        }\r\n                    }\r\n\r\n                    var originalWidth = parseInt(tuple[0]) / resolution;\r\n                    var originalHeight = parseInt(tuple[1]) / resolution;\r\n                    reader.readTuple(tuple);\r\n                    var offsetX = parseInt(tuple[0]) / resolution;\r\n                    var offsetY = parseInt(tuple[1]) / resolution;\r\n\r\n                    var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\r\n                    var trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\r\n\r\n                    //TODO: pixiv3 uses different frame/crop/trim\r\n\r\n                    if (PIXI.VERSION[0] == '4') {\r\n                        // pixi v4.0.0\r\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame, orig, trim, rotate);\r\n                    } else {\r\n                        // pixi v3.0.11\r\n                        var frame2 = new PIXI.Rectangle(x, y, width, height);\r\n                        var crop = frame2.clone();\r\n                        trim.width = originalWidth;\r\n                        trim.height = originalHeight;\r\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame2, crop, trim, rotate);\r\n                    }\r\n\r\n                    region.index = parseInt(reader.readValue());\r\n                    region.texture._updateUvs();\r\n\r\n                    self.regions.push(region);\r\n                }\r\n            }\r\n        }\r\n    },\r\n    findRegion: function (name)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n            if (regions[i].name == name) return regions[i];\r\n        return null;\r\n    },\r\n    dispose: function ()\r\n    {\r\n        var pages = this.pages;\r\n        for (var i = 0, n = pages.length; i < n; i++)\r\n            pages[i].rendererObject.destroy(true);\r\n    },\r\n    updateUVs: function (page)\r\n    {\r\n        var regions = this.regions;\r\n        for (var i = 0, n = regions.length; i < n; i++)\r\n        {\r\n            var region = regions[i];\r\n            if (region.page != page) continue;\r\n            region.texture._updateUvs();\r\n        }\r\n    }\r\n};\r\n\r\nspine.Atlas.Format = {\r\n    alpha: 0,\r\n    intensity: 1,\r\n    luminanceAlpha: 2,\r\n    rgb565: 3,\r\n    rgba4444: 4,\r\n    rgb888: 5,\r\n    rgba8888: 6\r\n};\r\n\r\nspine.Atlas.TextureFilter = {\r\n    nearest: 0,\r\n    linear: 1,\r\n    mipMap: 2,\r\n    mipMapNearestNearest: 3,\r\n    mipMapLinearNearest: 4,\r\n    mipMapNearestLinear: 5,\r\n    mipMapLinearLinear: 6\r\n};\r\n\r\nspine.Atlas.TextureWrap = {\r\n    mirroredRepeat: 0,\r\n    clampToEdge: 1,\r\n    repeat: 2\r\n};\r\nmodule.exports = spine.Atlas;\r\n","var spine = require('../SpineUtil');\r\nspine.RegionAttachment = require('./RegionAttachment');\r\nspine.MeshAttachment = require('./MeshAttachment');\r\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\r\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\r\nspine.AtlasAttachmentParser = function (atlas)\r\n{\r\n    this.atlas = atlas;\r\n};\r\nspine.AtlasAttachmentParser.prototype = {\r\n    newRegionAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\";\r\n        var attachment = new spine.RegionAttachment(name);\r\n        attachment.rendererObject = region;\r\n        attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\r\n        attachment.regionOffsetX = region.offsetX;\r\n        attachment.regionOffsetY = region.spineOffsetY;\r\n        attachment.regionWidth = region.width;\r\n        attachment.regionHeight = region.height;\r\n        attachment.regionOriginalWidth = region.originalWidth;\r\n        attachment.regionOriginalHeight = region.originalHeight;\r\n        return attachment;\r\n    },\r\n    newMeshAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\";\r\n        var attachment = new spine.MeshAttachment(name);\r\n        attachment.rendererObject = region;\r\n        // region.texture.on('update', spine.MeshAttachment.prototype.updateUVs.bind(attachment));\r\n        return attachment;\r\n    },\r\n    newWeightedMeshAttachment: function (skin, name, path)\r\n    {\r\n        var region = this.atlas.findRegion(path);\r\n        if (!region) throw \"Region not found in atlas: \" + path + \" (skinned mesh attachment: \" + name + \")\";\r\n        var attachment = new spine.WeightedMeshAttachment(name);\r\n        attachment.rendererObject = region;\r\n        // region.texture.on('update', spine.WeightedMeshAttachment.prototype.updateUVs.bind(attachment));\r\n        return attachment;\r\n    },\r\n    newBoundingBoxAttachment: function (skin, name)\r\n    {\r\n        return new spine.BoundingBoxAttachment(name);\r\n    }\r\n};\r\nmodule.exports = spine.AtlasAttachmentParser;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasPage = function ()\r\n{};\r\nspine.AtlasPage.prototype = {\r\n    name: null,\r\n    format: null,\r\n    minFilter: null,\r\n    magFilter: null,\r\n    uWrap: null,\r\n    vWrap: null,\r\n    rendererObject: null,\r\n    width: 0,\r\n    height: 0\r\n};\r\nmodule.exports = spine.AtlasPage;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasReader = function (text)\r\n{\r\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\r\n};\r\nspine.AtlasReader.prototype = {\r\n    index: 0,\r\n    trim: function (value)\r\n    {\r\n        return value.replace(/^\\s+|\\s+$/g, \"\");\r\n    },\r\n    readLine: function ()\r\n    {\r\n        if (this.index >= this.lines.length) return null;\r\n        return this.lines[this.index++];\r\n    },\r\n    readValue: function ()\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        return this.trim(line.substring(colon + 1));\r\n    },\r\n    /** Returns the number of tuple values read (1, 2 or 4). */\r\n    readTuple: function (tuple)\r\n    {\r\n        var line = this.readLine();\r\n        var colon = line.indexOf(\":\");\r\n        if (colon == -1) throw \"Invalid line: \" + line;\r\n        var i = 0, lastMatch = colon + 1;\r\n        for (; i < 3; i++)\r\n        {\r\n            var comma = line.indexOf(\",\", lastMatch);\r\n            if (comma == -1) break;\r\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\r\n            lastMatch = comma + 1;\r\n        }\r\n        tuple[i] = this.trim(line.substring(lastMatch));\r\n        return i + 1;\r\n    }\r\n};\r\nmodule.exports = spine.AtlasReader;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AtlasRegion = function ()\r\n{};\r\nspine.AtlasRegion.prototype = {\r\n    name: null,\r\n    /**\r\n     * @member {PIXI.Texture}\r\n     */\r\n    texture: null,\r\n\r\n    /**\r\n     * @member {PIXI.spine.Spine.AtlasPage}\r\n     */\r\n    page: null,\r\n    index: 0,\r\n    splits: null,\r\n    pads: null\r\n};\r\n\r\nObject.defineProperties(spine.AtlasRegion.prototype, {\r\n    x: {\r\n        get: function() {\r\n            return this.texture.frame.x;\r\n        }\r\n    },\r\n    y: {\r\n        get: function() {\r\n            return this.texture.frame.y;\r\n        }\r\n    },\r\n    width: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            if (PIXI.VERSION[0] == '3') {\r\n                return tex.crop.width;\r\n            }\r\n            if (tex.trim) {\r\n                return tex.trim.width;\r\n            }\r\n            return tex.orig.width;\r\n        }\r\n    },\r\n    height: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            if (PIXI.VERSION[0] == '3') {\r\n                return tex.crop.height;\r\n            }\r\n            if (tex.trim) {\r\n                return tex.trim.height;\r\n            }\r\n            return tex.orig.height;\r\n        }\r\n    },\r\n    u: {\r\n        get: function() {\r\n            return this.texture._uvs.x0;\r\n        }\r\n    },\r\n    v: {\r\n        get: function() {\r\n            return this.texture._uvs.y0;\r\n        }\r\n    },\r\n    u2: {\r\n        get: function() {\r\n            return this.texture._uvs.x2;\r\n        }\r\n    },\r\n    v2: {\r\n        get: function() {\r\n            return this.texture._uvs.y2;\r\n        }\r\n    },\r\n    rotate: {\r\n        get: function() {\r\n            return !!this.texture.rotate;\r\n        }\r\n    },\r\n    offsetX: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            return tex.trim ? tex.trim.x : 0;\r\n        }\r\n    },\r\n    offsetY: {\r\n        get: function() {\r\n            console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\r\n            return this.spineOffsetY;\r\n        }\r\n    },\r\n    pixiOffsetY: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            return tex.trim ? tex.trim.y : 0;\r\n        }\r\n    },\r\n    spineOffsetY: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\r\n        }\r\n    },  \r\n    originalWidth: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            if (PIXI.VERSION[0] == '3') {\r\n                if (tex.trim) {\r\n                    return tex.trim.width;\r\n                }\r\n                return tex.crop.width;\r\n            }\r\n            return tex.orig.width;\r\n        }\r\n    },\r\n    originalHeight: {\r\n        get: function() {\r\n            var tex = this.texture;\r\n            if (PIXI.VERSION[0] == '3') {\r\n                if (tex.trim) {\r\n                    return tex.trim.height;\r\n                }\r\n                return tex.crop.height;\r\n            }\r\n            return tex.orig.height;\r\n        }\r\n    }\r\n});\r\n\r\nmodule.exports = spine.AtlasRegion;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Curves = require('./Curves');\r\nspine.Animation = require('./Animation');\r\nspine.AttachmentTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.attachmentNames = [];\r\n    this.attachmentNames.length = frameCount;\r\n};\r\nspine.AttachmentTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, attachmentName)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.attachmentNames[frameIndex] = attachmentName;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0])\r\n        {\r\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\r\n            return;\r\n        } else if (lastTime > time) //\r\n            lastTime = -1;\r\n\r\n        var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;\r\n        if (frames[frameIndex] < lastTime) return;\r\n\r\n        var attachmentName = this.attachmentNames[frameIndex];\r\n        skeleton.slots[this.slotIndex].setAttachment(\r\n            !attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\r\n    }\r\n};\r\nmodule.exports = spine.AttachmentTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AttachmentType = {\r\n    region: 0,\r\n    boundingbox: 1,\r\n    mesh: 2,\r\n    weightedmesh : 3,\r\n    skinnedmesh: 3,\r\n    linkedmesh: 4,\r\n    weightedlinkedmesh: 5\r\n};\r\nmodule.exports = spine.AttachmentType;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Bone = function (boneData, skeleton, parent)\r\n{\r\n    this.data = boneData;\r\n    this.skeleton = skeleton;\r\n    this.parent = parent;\r\n    this.matrix = new PIXI.Matrix();\r\n    this.setToSetupPose();\r\n};\r\nspine.Bone.yDown = false;\r\nspine.Bone.prototype = {\r\n    x: 0, y: 0,\r\n    rotation: 0, rotationIK: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    shearX: 0, shearY: 0,\r\n    flipX: false, flipY: false,\r\n\r\n    worldSignX: 1, worldSignY: 1,\r\n    update: function() {\r\n        this.rotationIK = this.rotation;\r\n        this.updateWorldTransform();\r\n    },\r\n    updateWorldTransform: function() {\r\n        var rotation = this.rotationIK;\r\n        var scaleX = this.scaleX;\r\n        var scaleY = this.scaleY;\r\n        var x = this.x;\r\n        var y = this.y;\r\n        var rotationX = rotation + this.shearX;\r\n        var rotationY = rotation + 90 + this.shearY;\r\n\r\n        var la = Math.cos(rotationX * spine.degRad) * scaleX, lb = Math.cos(rotationY * spine.degRad) * scaleY,\r\n            lc = Math.sin(rotationX * spine.degRad) * scaleX, ld = Math.sin(rotationY * spine.degRad) * scaleY;\r\n        var parent = this.parent;\r\n        var m = this.matrix;\r\n        var skeleton = this.skeleton;\r\n        if (!parent) { // Root bone.\r\n            if (skeleton.flipX) {\r\n                x = -x;\r\n                la = -la;\r\n                lb = -lb;\r\n            }\r\n            if (skeleton.flipY !== spine.Bone.yDown) {\r\n                y = -y;\r\n                lc = -lc;\r\n                ld = -ld;\r\n            }\r\n            m.a = la;\r\n            m.c = lb;\r\n            m.b = lc;\r\n            m.d = ld;\r\n            m.tx = x;\r\n            m.ty = y;\r\n            this.worldSignX = spine.signum(scaleX);\r\n            this.worldSignY = spine.signum(scaleY);\r\n            return;\r\n        }\r\n\r\n\r\n        var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\r\n        m.tx = pa * x + pb * y + parent.matrix.tx;\r\n        m.ty = pc * x + pd * y + parent.matrix.ty;\r\n        this.worldSignX = parent.worldSignX * spine.signum(scaleX);\r\n        this.worldSignY = parent.worldSignY * spine.signum(scaleY);\r\n        var data = this.data;\r\n\r\n        if (data.inheritRotation && data.inheritScale) {\r\n            m.a = pa * la + pb * lc;\r\n            m.c = pa * lb + pb * ld;\r\n            m.b = pc * la + pd * lc;\r\n            m.d = pc * lb + pd * ld;\r\n        } else {\r\n            if (data.inheritRotation) { // No scale inheritance.\r\n                pa = 1;\r\n                pb = 0;\r\n                pc = 0;\r\n                pd = 1;\r\n                do {\r\n                    cos = Math.cos(parent.rotationIK * spine.degRad);\r\n                    sin = Math.sin(parent.rotationIK * spine.degRad);\r\n                    var temp = pa * cos + pb * sin;\r\n                    pb = pa * -sin + pb * cos;\r\n                    pa = temp;\r\n                    temp = pc * cos + pd * sin;\r\n                    pd = pc * -sin + pd * cos;\r\n                    pc = temp;\r\n\r\n                    if (!parent.data.inheritRotation) break;\r\n                    parent = parent.parent;\r\n                } while (parent != null);\r\n                m.a = pa * la + pb * lc;\r\n                m.c = pa * lb + pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n            } else if (data.inheritScale) { // No rotation inheritance.\r\n                pa = 1;\r\n                pb = 0;\r\n                pc = 0;\r\n                pd = 1;\r\n                do {\r\n                    var r = parent.rotationIK;\r\n                    cos = Math.cos(r * spine.degRad);\r\n                    sin = Math.sin(r * spine.degRad);\r\n                    var psx = parent.scaleX, psy = parent.scaleY;\r\n                    var za = cos * psx, zb = -sin * psy, zc = sin * psx, zd = cos * psy;\r\n                    temp = pa * za + pb * zc;\r\n                    pb = pa * zb + pb * zd;\r\n                    pa = temp;\r\n                    temp = pc * za + pd * zc;\r\n                    pd = pc * zb + pd * zd;\r\n                    pc = temp;\r\n\r\n                    if (psx < 0) {\r\n                        r = -r;\r\n                    } else {\r\n                        sin = -sin;\r\n                    }\r\n                    temp = pa * cos + pb * sin;\r\n                    pb = pa * -sin + pb * cos;\r\n                    pa = temp;\r\n                    temp = pc * cos + pd * sin;\r\n                    pd = pc * -sin + pd * cos;\r\n                    pc = temp;\r\n\r\n                    if (!parent.data.inheritScale) break;\r\n                    parent = parent.parent;\r\n                } while (parent != null);\r\n                m.a = pa * la + pb * lc;\r\n                m.c = pa * lb + pb * ld;\r\n                m.b = pc * la + pd * lc;\r\n                m.d = pc * lb + pd * ld;\r\n            } else {\r\n                m.a = la;\r\n                m.c = lb;\r\n                m.b = lc;\r\n                m.d = ld;\r\n            }\r\n            if (skeleton.flipX) {\r\n                m.a = -m.a;\r\n                m.c = -m.c;\r\n            }\r\n            if (skeleton.flipY !== spine.Bone.yDown) {\r\n                m.b = -m.b;\r\n                m.d = -m.d;\r\n            }\r\n        }\r\n    },\r\n\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.x = data.x;\r\n        this.y = data.y;\r\n        this.rotation = data.rotation;\r\n        this.rotationIK = this.rotation;\r\n        this.scaleX = data.scaleX;\r\n        this.scaleY = data.scaleY;\r\n        this.shearX = data.shearX;\r\n        this.shearY = data.shearY;\r\n    },\r\n    worldToLocal: function (world)\r\n    {\r\n        var m = this.matrix;\r\n        var dx = world[0] - m.tx, dy = m.ty;\r\n        var invDet = 1 / (m.a * m.d - m.b * m.c);\r\n        //Yep, its a bug in original spine. I hope they'll fix it: https://github.com/EsotericSoftware/spine-runtimes/issues/544\r\n        world[0] = dx * m.a * invDet - dy * m.c * invDet;\r\n        world[1] = dy * m.d * invDet - dx * m.b * invDet;\r\n    },\r\n    localToWorld: function (local)\r\n    {\r\n        var localX = local[0], localY = local[1];\r\n        var m = this.matrix;\r\n        local[0] = localX * m.a + localY * m.c + m.tx;\r\n        local[1] = localX * m.b + localY * m.d + m.ty;\r\n    },\r\n    getWorldRotationX: function() {\r\n        return Math.atan2(this.matrix.b, this.matrix.a) * spine.radDeg;\r\n\r\n    },\r\n    getWorldRotationY: function() {\r\n        return Math.atan2(this.matrix.d, this.matrix.c) * spine.radDeg;\r\n    },\r\n    getWorldScaleX: function() {\r\n        var a = this.matrix.a;\r\n        var b = this.matrix.b;\r\n        return Math.sqrt(a*a+b*b);\r\n    },\r\n    getWorldScaleY: function() {\r\n        var c = this.matrix.c;\r\n        var d = this.matrix.d;\r\n        return Math.sqrt(c * c + d * d);\r\n    }\r\n};\r\n\r\nObject.defineProperties(spine.Bone.prototype, {\r\n    worldX: {\r\n        get: function() {\r\n            return this.matrix.tx;\r\n        }\r\n    },\r\n    worldY:  {\r\n        get: function() {\r\n            return this.matrix.ty;\r\n        }\r\n    }\r\n});\r\n\r\nmodule.exports = spine.Bone;\r\n","var spine = require('../SpineUtil');\r\nspine.BoneData = function (name, parent)\r\n{\r\n    this.name = name;\r\n    this.parent = parent;\r\n};\r\nspine.BoneData.prototype = {\r\n    length: 0,\r\n    x: 0, y: 0,\r\n    rotation: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    shearX: 0, shearY: 0,\r\n    inheritScale: true,\r\n    inheritRotation: true\r\n};\r\nmodule.exports = spine.BoneData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.BoundingBoxAttachment = function (name)\r\n{\r\n    this.name = name;\r\n    this.vertices = [];\r\n};\r\nspine.BoundingBoxAttachment.prototype = {\r\n    type: spine.AttachmentType.boundingbox,\r\n    computeWorldVertices: function (x, y, bone, worldVertices)\r\n    {\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\r\n        var vertices = this.vertices;\r\n        for (var i = 0, n = vertices.length; i < n; i += 2)\r\n        {\r\n            var px = vertices[i];\r\n            var py = vertices[i + 1];\r\n            worldVertices[i] = px * m00 + py * m01 + x;\r\n            worldVertices[i + 1] = px * m10 + py * m11 + y;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.BoundingBoxAttachment;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ColorTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, r, g, b, a, ...\r\n    this.frames.length = frameCount * 5;\r\n};\r\nspine.ColorTimeline.prototype = {\r\n    slotIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 5;\r\n    },\r\n    setFrame: function (frameIndex, time, r, g, b, a)\r\n    {\r\n        frameIndex *= 5;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = r;\r\n        this.frames[frameIndex + 2] = g;\r\n        this.frames[frameIndex + 3] = b;\r\n        this.frames[frameIndex + 4] = a;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var r, g, b, a;\r\n        if (time >= frames[frames.length - 5])\r\n        {\r\n            // Time is after last frame.\r\n            var i = frames.length - 1;\r\n            r = frames[i - 3];\r\n            g = frames[i - 2];\r\n            b = frames[i - 1];\r\n            a = frames[i];\r\n        } else {\r\n            // Interpolate between the previous frame and the current frame.\r\n            var frameIndex = spine.Animation.binarySearch(frames, time, 5);\r\n            var prevFrameR = frames[frameIndex - 4];\r\n            var prevFrameG = frames[frameIndex - 3];\r\n            var prevFrameB = frames[frameIndex - 2];\r\n            var prevFrameA = frames[frameIndex - 1];\r\n            var frameTime = frames[frameIndex];\r\n            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*PREV_FRAME_TIME*/] - frameTime);\r\n            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\r\n\r\n            r = prevFrameR + (frames[frameIndex + 1/*FRAME_R*/] - prevFrameR) * percent;\r\n            g = prevFrameG + (frames[frameIndex + 2/*FRAME_G*/] - prevFrameG) * percent;\r\n            b = prevFrameB + (frames[frameIndex + 3/*FRAME_B*/] - prevFrameB) * percent;\r\n            a = prevFrameA + (frames[frameIndex + 4/*FRAME_A*/] - prevFrameA) * percent;\r\n        }\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        if (alpha < 1)\r\n        {\r\n            slot.r += (r - slot.r) * alpha;\r\n            slot.g += (g - slot.g) * alpha;\r\n            slot.b += (b - slot.b) * alpha;\r\n            slot.a += (a - slot.a) * alpha;\r\n        } else {\r\n            slot.r = r;\r\n            slot.g = g;\r\n            slot.b = b;\r\n            slot.a = a;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.ColorTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Curves = function (frameCount)\r\n{\r\n    this.curves = []; // type, x, y, ...\r\n    //this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;\r\n};\r\nspine.Curves.prototype = {\r\n    setLinear: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 0/*LINEAR*/;\r\n    },\r\n    setStepped: function (frameIndex)\r\n    {\r\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 1/*STEPPED*/;\r\n    },\r\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\r\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\r\n     * the difference between the keyframe's values. */\r\n    setCurve: function (frameIndex, cx1, cy1, cx2, cy2)\r\n    {\r\n        var subdiv1 = 1 / 10/*BEZIER_SEGMENTS*/, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;\r\n        var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;\r\n        var tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;\r\n        var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;\r\n        var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;\r\n        var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;\r\n\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var curves = this.curves;\r\n        curves[i++] = 2/*BEZIER*/;\r\n\r\n        var x = dfx, y = dfy;\r\n        for (var n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            curves[i] = x;\r\n            curves[i + 1] = y;\r\n            dfx += ddfx;\r\n            dfy += ddfy;\r\n            ddfx += dddfx;\r\n            ddfy += dddfy;\r\n            x += dfx;\r\n            y += dfy;\r\n        }\r\n    },\r\n    getCurvePercent: function (frameIndex, percent)\r\n    {\r\n        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\r\n        var curves = this.curves;\r\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\r\n        var type = curves[i];\r\n        if (type === 0/*LINEAR*/) return percent;\r\n        if (type == 1/*STEPPED*/) return 0;\r\n        i++;\r\n        var x = 0;\r\n        for (var start = i, n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\r\n        {\r\n            x = curves[i];\r\n            if (x >= percent)\r\n            {\r\n                var prevX, prevY;\r\n                if (i == start)\r\n                {\r\n                    prevX = 0;\r\n                    prevY = 0;\r\n                } else {\r\n                    prevX = curves[i - 2];\r\n                    prevY = curves[i - 1];\r\n                }\r\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\r\n            }\r\n        }\r\n        var y = curves[i - 1];\r\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\r\n    }\r\n};\r\nmodule.exports = spine.Curves;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.DrawOrderTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.drawOrders = [];\r\n    this.drawOrders.length = frameCount;\r\n};\r\nspine.DrawOrderTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, drawOrder)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.drawOrders[frameIndex] = drawOrder;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\r\n            frameIndex = frames.length - 1;\r\n        else\r\n            frameIndex = spine.Animation.binarySearch1(frames, time) - 1;\r\n\r\n        var drawOrder = skeleton.drawOrder;\r\n        var slots = skeleton.slots;\r\n        var drawOrderToSetupIndex = this.drawOrders[frameIndex];\r\n        if (drawOrderToSetupIndex)\r\n        {\r\n            for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\r\n            {\r\n                drawOrder[i] = drawOrderToSetupIndex[i];\r\n            }\r\n        }\r\n\r\n    }\r\n};\r\nmodule.exports = spine.DrawOrderTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Event = function (data)\r\n{\r\n    this.data = data;\r\n};\r\nspine.Event.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.Event;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.EventData = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.EventData.prototype = {\r\n    intValue: 0,\r\n    floatValue: 0,\r\n    stringValue: null\r\n};\r\nmodule.exports = spine.EventData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.EventTimeline = function (frameCount)\r\n{\r\n    this.frames = []; // time, ...\r\n    this.frames.length = frameCount;\r\n    this.events = [];\r\n    this.events.length = frameCount;\r\n};\r\nspine.EventTimeline.prototype = {\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, event)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.events[frameIndex] = event;\r\n    },\r\n    /** Fires events for frames > lastTime and <= time. */\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        if (!firedEvents) return;\r\n\r\n        var frames = this.frames;\r\n        var frameCount = frames.length;\r\n\r\n        if (lastTime > time)\r\n        { // Fire events after last time for looped animations.\r\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\r\n            lastTime = -1;\r\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\r\n            return;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameIndex;\r\n        if (lastTime < frames[0])\r\n            frameIndex = 0;\r\n        else\r\n        {\r\n            frameIndex = spine.Animation.binarySearch1(frames, lastTime);\r\n            var frame = frames[frameIndex];\r\n            while (frameIndex > 0)\r\n            { // Fire multiple events with the same frame.\r\n                if (frames[frameIndex - 1] != frame) break;\r\n                frameIndex--;\r\n            }\r\n        }\r\n        var events = this.events;\r\n        for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)\r\n            firedEvents.push(events[frameIndex]);\r\n    }\r\n};\r\nmodule.exports = spine.EventTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.FfdTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = [];\r\n    this.frames.length = frameCount;\r\n    this.frameVertices = [];\r\n    this.frameVertices.length = frameCount;\r\n};\r\nspine.FfdTimeline.prototype = {\r\n    slotIndex: 0,\r\n    attachment: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length;\r\n    },\r\n    setFrame: function (frameIndex, time, vertices)\r\n    {\r\n        this.frames[frameIndex] = time;\r\n        this.frameVertices[frameIndex] = vertices;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var slot = skeleton.slots[this.slotIndex];\r\n        var slotAttachment = slot.attachment;\r\n        if (slotAttachment && (!slotAttachment.applyFFD || !slotAttachment.applyFFD(this.attachment))) return;\r\n\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var frameVertices = this.frameVertices;\r\n        var vertexCount = frameVertices[0].length;\r\n\r\n        var vertices = slot.attachmentVertices;\r\n        if (vertices.length != vertexCount) {\r\n            vertices = slot.attachmentVertices = [];\r\n            for (var k = 0; k < vertexCount; k++) vertices.push(0);\r\n            // Don't mix from uninitialized slot vertices.\r\n            alpha = 1;\r\n        }\r\n\r\n        if (time >= frames[frames.length - 1])\r\n        { // Time is after last frame.\r\n            var lastVertices = frameVertices[frames.length - 1];\r\n            if (alpha < 1)\r\n            {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\r\n            } else {\r\n                for (var i = 0; i < vertexCount; i++)\r\n                    vertices[i] = lastVertices[i];\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch1(frames, time);\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));\r\n\r\n        var prevVertices = frameVertices[frameIndex - 1];\r\n        var nextVertices = frameVertices[frameIndex];\r\n\r\n        if (alpha < 1)\r\n        {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\r\n            }\r\n        } else {\r\n            for (var i = 0; i < vertexCount; i++)\r\n            {\r\n                var prev = prevVertices[i];\r\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.FfdTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.IkConstraint = function (data, skeleton)\r\n{\r\n    this.data = data;\r\n    this.mix = data.mix;\r\n    this.bendDirection = data.bendDirection;\r\n\r\n    this.bones = [];\r\n    for (var i = 0, n = data.bones.length; i < n; i++)\r\n        this.bones.push(skeleton.findBone(data.bones[i].name));\r\n    this.target = skeleton.findBone(data.target.name);\r\n};\r\nspine.IkConstraint.prototype = {\r\n    update: function() {\r\n        this.apply();\r\n    },\r\n    apply: function ()\r\n    {\r\n        var target = this.target;\r\n        var bones = this.bones;\r\n        switch (bones.length)\r\n        {\r\n        case 1:\r\n            spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);\r\n            break;\r\n        case 2:\r\n            spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\r\n            break;\r\n        }\r\n    }\r\n};\r\n/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\r\n * coordinate system. */\r\nspine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha)\r\n{\r\n    var parentRotation = bone.parent ? bone.parent.getWorldRotationX(): 0;\r\n    var rotation = bone.rotation;\r\n    var rotationIK = Math.atan2(targetY - bone.worldY, targetX - bone.worldX) * spine.radDeg - parentRotation;\r\n    if ((bone.worldSignX != bone.worldSignY) != (bone.skeleton.flipX != (bone.skeleton.flipY != spine.Bone.yDown))) rotationIK = 360 - rotationIK;\r\n\r\n    //OLD ONE:\r\n\r\n    // float parentRotation = bone.parent == null ? 0 : bone.parent.getWorldRotationX();\r\n    // float rotation = bone.rotation;\r\n    // float rotationIK = atan2(targetY - bone.worldY, targetX - bone.worldX) * radDeg - parentRotation;\r\n    // if ((bone.worldSignX != bone.worldSignY) != (bone.skeleton.flipX != bone.skeleton.flipY)) rotationIK = 360 - rotationIK;\r\n\r\n    //NEW ONE\r\n\r\n    // var pp = bone.parent;\r\n    // float id = 1 / (pp.a * pp.d - pp.b * pp.c);\r\n    // float x = targetX - pp.worldX, y = targetY - pp.worldY;\r\n    // float tx = (x * pp.d - y * pp.b) * id - bone.x, ty = (y * pp.a - x * pp.c) * id - bone.y;\r\n    // float rotationIK = atan2(ty, tx) * radDeg - bone.shearX;\r\n    // if (bone.scaleX < 0) rotationIK += 180;\r\n\r\n\r\n    if (rotationIK > 180)\r\n        rotationIK -= 360;\r\n    else if (rotationIK < -180) rotationIK += 360;\r\n    bone.rotationIK = rotation + (rotationIK - rotation) * alpha;\r\n    bone.updateWorldTransform();\r\n};\r\n/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\r\n * target is specified in the world coordinate system.\r\n * @param child Any descendant bone of the parent. */\r\nspine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDir, alpha)\r\n{\r\n    if (alpha == 0) return;\r\n    var px = parent.x, py = parent.y, psx = parent.scaleX, psy = parent.scaleY, csx = child.scaleX, cy = child.y;\r\n    var offset1, offset2, sign2;\r\n    if (psx < 0) {\r\n        psx = -psx;\r\n        offset1 = 180;\r\n        sign2 = -1;\r\n    } else {\r\n        offset1 = 0;\r\n        sign2 = 1;\r\n    }\r\n    if (psy < 0) {\r\n        psy = -psy;\r\n        sign2 = -sign2;\r\n    }\r\n    if (csx < 0) {\r\n        csx = -csx;\r\n        offset2 = 180;\r\n    } else\r\n        offset2 = 0;\r\n    var pp = parent.parent;\r\n    var ppm = pp.matrix;\r\n    var tx, ty, dx, dy;\r\n    if (pp == null) {\r\n        tx = targetX - px;\r\n        ty = targetY - py;\r\n        dx = child.worldX - px;\r\n        dy = child.worldY - py;\r\n    } else {\r\n        var a = ppm.a, b = ppm.c, c = ppm.b, d = ppm.d, invDet = 1 / (a * d - b * c);\r\n        var wx = ppm.tx, wy = ppm.ty, x = targetX - wx, y = targetY - wy;\r\n        tx = (x * d - y * b) * invDet - px;\r\n        ty = (y * a - x * c) * invDet - py;\r\n        x = child.worldX - wx;\r\n        y = child.worldY - wy;\r\n        dx = (x * d - y * b) * invDet - px;\r\n        dy = (y * a - x * c) * invDet - py;\r\n    }\r\n\r\n    //OLD ONE\r\n    // float tx, ty, dx, dy;\r\n    // if (pp == null) {\r\n    //     tx = targetX - px;\r\n    //     ty = targetY - py;\r\n    //     dx = child.worldX - px;\r\n    //     dy = child.worldY - py;\r\n    // } else {\r\n    //     float a = pp.a, b = pp.b, c = pp.c, d = pp.d, invDet = 1 / (a * d - b * c);\r\n    //     float wx = pp.worldX, wy = pp.worldY, x = targetX - wx, y = targetY - wy;\r\n    //     tx = (x * d - y * b) * invDet - px;\r\n    //     ty = (y * a - x * c) * invDet - py;\r\n    //     x = child.worldX - wx;\r\n    //     y = child.worldY - wy;\r\n    //     dx = (x * d - y * b) * invDet - px;\r\n    //     dy = (y * a - x * c) * invDet - py;\r\n    // }\r\n\r\n    //NEW ONE\r\n    // float ppa = pp.a, ppb = pp.b, ppc = pp.c, ppd = pp.d, id = 1 / (ppa * ppd - ppb * ppc);\r\n    // float x = targetX - pp.worldX, y = targetY - pp.worldY;\r\n    // float tx = (x * ppd - y * ppb) * id - px, ty = (y * ppa - x * ppc) * id - py;\r\n    // x = child.worldX - pp.worldX;\r\n    // y = child.worldY - pp.worldY;\r\n    // float dx = (x * ppd - y * ppb) * id - px, dy = (y * ppa - x * ppc) * id - py;\r\n\r\n    var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\r\n    outer:\r\n        if (Math.abs(psx - psy) <= 0.0001) {\r\n            l2 *= psx;\r\n            var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\r\n            if (cos < -1)\r\n                cos = -1;\r\n            else if (cos > 1) cos = 1;\r\n            a2 = Math.acos(cos) * bendDir;\r\n            var a = l1 + l2 * cos, o = l2 * Math.sin(a2);\r\n            a1 = Math.atan2(ty * a - tx * o, tx * a + ty * o);\r\n        } else {\r\n            cy = 0;\r\n            var a = psx * l2, b = psy * l2, ta = Math.atan2(ty, tx);\r\n            var aa = a * a, bb = b * b, ll = l1 * l1, dd = tx * tx + ty * ty;\r\n            var c0 = bb * ll + aa * dd - aa * bb, c1 = -2 * bb * l1, c2 = bb - aa;\r\n            var d = c1 * c1 - 4 * c2 * c0;\r\n            if (d >= 0) {\r\n                var q = Math.sqrt(d);\r\n                if (c1 < 0) q = -q;\r\n                q = -(c1 + q) / 2;\r\n                var r0 = q / c2, r1 = c0 / q;\r\n                var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\r\n                if (r * r <= dd) {\r\n                    var y = Math.sqrt(dd - r * r) * bendDir;\r\n                    a1 = ta - Math.atan2(y, r);\r\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\r\n                    break outer;\r\n                }\r\n            }\r\n            var minAngle = 0, minDist = Infinity, minX = 0, minY = 0;\r\n            var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;\r\n            var x = l1 + a, dist = x * x;\r\n            if (dist > maxDist) {\r\n                maxAngle = 0;\r\n                maxDist = dist;\r\n                maxX = x;\r\n            }\r\n            x = l1 - a;\r\n            dist = x * x;\r\n            if (dist < minDist) {\r\n                minAngle = Math.PI;\r\n                minDist = dist;\r\n                minX = x;\r\n            }\r\n            var angle = Math.acos(-a * l1 / (aa - bb));\r\n            x = a * Math.cos(angle) + l1;\r\n            var y = b * Math.sin(angle);\r\n            dist = x * x + y * y;\r\n            if (dist < minDist) {\r\n                minAngle = angle;\r\n                minDist = dist;\r\n                minX = x;\r\n                minY = y;\r\n            }\r\n            if (dist > maxDist) {\r\n                maxAngle = angle;\r\n                maxDist = dist;\r\n                maxX = x;\r\n                maxY = y;\r\n            }\r\n            if (dd <= (minDist + maxDist) / 2) {\r\n                a1 = ta - Math.atan2(minY * bendDir, minX);\r\n                a2 = minAngle * bendDir;\r\n            } else {\r\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\r\n                a2 = maxAngle * bendDir;\r\n            }\r\n        }\r\n    var offset = Math.atan2(cy, child.x) * sign2;\r\n    a1 = (a1 - offset) * spine.radDeg + offset1;\r\n    a2 = (a2 + offset) * spine.radDeg * sign2 + offset2;\r\n    if (a1 > 180)\r\n        a1 -= 360;\r\n    else if (a1 < -180) a1 += 360;\r\n    if (a2 > 180)\r\n        a2 -= 360;\r\n    else if (a2 < -180) a2 += 360;\r\n    var rotation = parent.rotation;\r\n    parent.rotationIK = rotation + (a1 - rotation) * alpha;\r\n    parent.updateWorldTransform();\r\n    rotation = child.rotation;\r\n    child.rotationIK = rotation + (a2 - rotation) * alpha;\r\n    child.updateWorldTransform();\r\n};\r\nmodule.exports = spine.IkConstraint;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.IkConstraintData = function (name)\r\n{\r\n    this.name = name;\r\n    this.bones = [];\r\n};\r\nspine.IkConstraintData.prototype = {\r\n    target: null,\r\n    bendDirection: 1,\r\n    mix: 1\r\n};\r\nmodule.exports = spine.IkConstraintData;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.IkConstraintTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, mix, bendDirection, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.IkConstraintTimeline.prototype = {\r\n    ikConstraintIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, mix, bendDirection)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = mix;\r\n        this.frames[frameIndex + 2] = bendDirection;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;\r\n            ikConstraint.bendDirection = frames[frames.length - 1];\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameMix = frames[frameIndex + -2/*PREV_FRAME_MIX*/];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        var mix = prevFrameMix + (frames[frameIndex + 1/*FRAME_MIX*/] - prevFrameMix) * percent;\r\n        ikConstraint.mix += (mix - ikConstraint.mix) * alpha;\r\n        ikConstraint.bendDirection = frames[frameIndex + -1/*PREV_FRAME_BEND_DIRECTION*/];\r\n    }\r\n};\r\nmodule.exports = spine.IkConstraintTimeline;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.MeshAttachment = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.MeshAttachment.prototype = {\r\n    type: spine.AttachmentType.mesh,\r\n    parentMesh: null,\r\n    inheritFFD: false,\r\n    vertices: null,\r\n    uvs: null,\r\n    regionUVs: null,\r\n    triangles: null,\r\n    hullLength: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    edges: null,\r\n    width: 0, height: 0,\r\n    updateUVs: function ()\r\n    {\r\n        var n = this.regionUVs.length;\r\n        if (!this.uvs || this.uvs.length != n)\r\n        {\r\n            this.uvs = new spine.Float32Array(n);\r\n        }\r\n        var region = this.rendererObject;\r\n        if (!region) return;\r\n        var texture = region.texture;\r\n        var r = texture._uvs;\r\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\r\n        var x = region.offsetX, y = region.pixiOffsetY;\r\n        for (var i = 0; i < n; i += 2)\r\n        {\r\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\r\n            u = (u * w2 - x) / w1;\r\n            v = (v * h2 - y) / h1;\r\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\r\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\r\n        }\r\n    },\r\n    computeWorldVertices: function (x, y, slot, worldVertices)\r\n    {\r\n        var bone = slot.bone;\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\r\n        var vertices = this.vertices;\r\n        var verticesCount = vertices.length;\r\n        if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;\r\n        for (var i = 0; i < verticesCount; i += 2)\r\n        {\r\n            var vx = vertices[i];\r\n            var vy = vertices[i + 1];\r\n            worldVertices[i] = vx * m00 + vy * m01 + x;\r\n            worldVertices[i + 1] = vx * m10 + vy * m11 + y;\r\n        }\r\n    },\r\n    applyFFD: function(sourceAttachment) {\r\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\r\n    },\r\n    setParentMesh: function(parentMesh) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh != null) {\r\n            this.vertices = parentMesh.vertices;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n        }\r\n    },\r\n    hackRegion: function(newRegion) {\r\n        if (!newRegion) {\r\n            if (!this.oldRegion) return;\r\n            newRegion = this.oldRegion;\r\n        }\r\n        if (!this.oldRegion) {\r\n            this.oldRegion = this.rendererObject;\r\n        }\r\n        this.rendererObject = newRegion;\r\n        this.updateUVs();\r\n    }\r\n};\r\nmodule.exports = spine.MeshAttachment;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.RegionAttachment = function (name)\r\n{\r\n    this.name = name;\r\n    this.offset = [];\r\n    this.offset.length = 8;\r\n    this.uvs = [];\r\n    this.uvs.length = 8;\r\n};\r\nspine.RegionAttachment.prototype = {\r\n    type: spine.AttachmentType.region,\r\n    x: 0, y: 0,\r\n    rotation: 0,\r\n    scaleX: 1, scaleY: 1,\r\n    width: 0, height: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    regionOffsetX: 0, regionOffsetY: 0,\r\n    regionWidth: 0, regionHeight: 0,\r\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\r\n    setUVs: function (u, v, u2, v2, rotate)\r\n    {\r\n        var uvs = this.uvs;\r\n        if (rotate)\r\n        {\r\n            uvs[2/*X2*/] = u;\r\n            uvs[3/*Y2*/] = v2;\r\n            uvs[4/*X3*/] = u;\r\n            uvs[5/*Y3*/] = v;\r\n            uvs[6/*X4*/] = u2;\r\n            uvs[7/*Y4*/] = v;\r\n            uvs[0/*X1*/] = u2;\r\n            uvs[1/*Y1*/] = v2;\r\n        } else {\r\n            uvs[0/*X1*/] = u;\r\n            uvs[1/*Y1*/] = v2;\r\n            uvs[2/*X2*/] = u;\r\n            uvs[3/*Y2*/] = v;\r\n            uvs[4/*X3*/] = u2;\r\n            uvs[5/*Y3*/] = v;\r\n            uvs[6/*X4*/] = u2;\r\n            uvs[7/*Y4*/] = v2;\r\n        }\r\n    },\r\n    updateOffset: function ()\r\n    {\r\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\r\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\r\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\r\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\r\n        var localX2 = localX + this.regionWidth * regionScaleX;\r\n        var localY2 = localY + this.regionHeight * regionScaleY;\r\n        var radians = this.rotation * spine.degRad;\r\n        var cos = Math.cos(radians);\r\n        var sin = Math.sin(radians);\r\n        var localXCos = localX * cos + this.x;\r\n        var localXSin = localX * sin;\r\n        var localYCos = localY * cos + this.y;\r\n        var localYSin = localY * sin;\r\n        var localX2Cos = localX2 * cos + this.x;\r\n        var localX2Sin = localX2 * sin;\r\n        var localY2Cos = localY2 * cos + this.y;\r\n        var localY2Sin = localY2 * sin;\r\n        var offset = this.offset;\r\n        offset[0/*X1*/] = localXCos - localYSin;\r\n        offset[1/*Y1*/] = localYCos + localXSin;\r\n        offset[2/*X2*/] = localXCos - localY2Sin;\r\n        offset[3/*Y2*/] = localY2Cos + localXSin;\r\n        offset[4/*X3*/] = localX2Cos - localY2Sin;\r\n        offset[5/*Y3*/] = localY2Cos + localX2Sin;\r\n        offset[6/*X4*/] = localX2Cos - localYSin;\r\n        offset[7/*Y4*/] = localYCos + localX2Sin;\r\n    },\r\n    computeVertices: function (x, y, bone, vertices)\r\n    {\r\n        x += bone.worldX;\r\n        y += bone.worldY;\r\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\r\n        var offset = this.offset;\r\n        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\r\n        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\r\n        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\r\n        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\r\n        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\r\n        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\r\n        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\r\n        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\r\n    },\r\n    hackRegion: function(newRegion) {\r\n        if (!newRegion) {\r\n            if (!this.oldRegion) return;\r\n            newRegion = this.oldRegion;\r\n        }\r\n        if (!this.oldRegion) {\r\n            this.oldRegion = this.rendererObject;\r\n            this.oldRegion.size = { width: this.width, height: this.height };\r\n        }\r\n        this.rendererObject = newRegion;\r\n        if (newRegion.size) {\r\n            this.width = newRegion.size.width;\r\n            this.height = newRegion.size.height;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.RegionAttachment;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.RotateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, angle, ...\r\n    this.frames.length = frameCount * 2;\r\n};\r\nspine.RotateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 2;\r\n    },\r\n    setFrame: function (frameIndex, time, angle)\r\n    {\r\n        frameIndex *= 2;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = angle;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 2])\r\n        { // Time is after last frame.\r\n            var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\r\n            while (amount > 180)\r\n                amount -= 360;\r\n            while (amount < -180)\r\n                amount += 360;\r\n            bone.rotation += amount * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 2);\r\n        var prevFrameValue = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\r\n\r\n        var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - prevFrameValue;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;\r\n        while (amount > 180)\r\n            amount -= 360;\r\n        while (amount < -180)\r\n            amount += 360;\r\n        bone.rotation += amount * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.RotateTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ScaleTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ScaleTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;\r\n            bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;\r\n        bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ScaleTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.ShearTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.ShearTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.shearX += (bone.data.shearX + frames[frames.length - 2] - bone.shearX) * alpha;\r\n            bone.shearY += (bone.data.shearY + frames[frames.length - 1] - bone.shearY) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.shearX += (bone.data.shearX + (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.shearX) * alpha;\r\n        bone.shearY += (bone.data.shearY + (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.shearY) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.ShearTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Bone = require('./Bone');\r\nspine.Slot = require('./Slot');\r\nspine.IkConstraint = require('./IkConstraint');\r\nspine.Skeleton = function (skeletonData)\r\n{\r\n    this.data = skeletonData;\r\n\r\n    this.bones = [];\r\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++)\r\n    {\r\n        var boneData = skeletonData.bones[i];\r\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\r\n        this.bones.push(new spine.Bone(boneData, this, parent));\r\n    }\r\n\r\n    this.slots = [];\r\n    this.drawOrder = [];\r\n    for (var i = 0, n = skeletonData.slots.length; i < n; i++)\r\n    {\r\n        var slotData = skeletonData.slots[i];\r\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\r\n        var slot = new spine.Slot(slotData, bone);\r\n        this.slots.push(slot);\r\n        this.drawOrder.push(i);\r\n    }\r\n\r\n    this.ikConstraints = [];\r\n    for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++)\r\n        this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));\r\n\r\n    this.transformConstraints = [];\r\n    for (var i = 0, n = skeletonData.transformConstraints.length; i < n; i++)\r\n        this.transformConstraints.push(new spine.TransformConstraint(skeletonData.transformConstraints[i], this));\r\n\r\n    this.boneCache = [];\r\n    this.updateCache();\r\n};\r\nspine.Skeleton.prototype = {\r\n    x: 0, y: 0,\r\n    skin: null,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    time: 0,\r\n    flipX: false, flipY: false,\r\n    /** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */\r\n    updateCache: function ()\r\n    {\r\n        var ikConstraints = this.ikConstraints;\r\n        var ikConstraintsCount = ikConstraints.length;\r\n        var transformConstraints = this.transformConstraints;\r\n        var transformConstraintsCount = transformConstraints.length;\r\n\r\n        var boneCache = this.boneCache;\r\n        boneCache.length = 0;\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n        {\r\n            var bone = bones[i];\r\n            boneCache.push(bone);\r\n            for (var j=0; j < transformConstraintsCount; j++) {\r\n                if (transformConstraints[j].bone == bone) {\r\n                    boneCache.push(transformConstraints[j]);\r\n                }\r\n            }\r\n            for (var j=0; j < ikConstraintsCount; j++) {\r\n                if (ikConstraints[j].bones[ikConstraints[j].bones.length-1] == bone) {\r\n                    boneCache.push(ikConstraints[j]);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    },\r\n    /** Updates the world transform for each bone. */\r\n    updateWorldTransform: function ()\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n        {\r\n            var bone = bones[i];\r\n            bone.rotationIK = bone.rotation;\r\n        }\r\n        var boneCache = this.boneCache;\r\n        for (var i = 0, n = boneCache.length; i < n; i++) {\r\n            boneCache[i].update();\r\n        }\r\n    },\r\n    /** Sets the bones and slots to their setup pose values. */\r\n    setToSetupPose: function ()\r\n    {\r\n        this.setBonesToSetupPose();\r\n        this.setSlotsToSetupPose();\r\n    },\r\n    setBonesToSetupPose: function ()\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            bones[i].setToSetupPose();\r\n\r\n        var ikConstraints = this.ikConstraints;\r\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\r\n        {\r\n            var ikConstraint = ikConstraints[i];\r\n            ikConstraint.bendDirection = ikConstraint.data.bendDirection;\r\n            ikConstraint.mix = ikConstraint.data.mix;\r\n        }\r\n\r\n        var transformConstraints = this.transformConstraints;\r\n        for (var i = 0, n = transformConstraints.length; i < n; i++)\r\n        {\r\n            var constraint = transformConstraints[i];\r\n            var data = constraint.data;\r\n            constraint.rotateMix = data.rotateMix;\r\n            constraint.translateMix = data.translateMix;\r\n            constraint.scaleMix = data.scaleMix;\r\n            constraint.shearMix = data.shearMix;\r\n        }\r\n    },\r\n    setSlotsToSetupPose: function ()\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            slots[i].setToSetupPose(i);\r\n        }\r\n\r\n        this.resetDrawOrder();\r\n    },\r\n    /** @return May return null. */\r\n    getRootBone: function ()\r\n    {\r\n        return this.bones.length ? this.bones[0] : null;\r\n    },\r\n    /** @return May be null. */\r\n    findBone: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return bones[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findBoneIndex: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].data.name == boneName) return i;\r\n        return -1;\r\n    },\r\n    /** @return May be null. */\r\n    findSlot: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return slots[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findSlotIndex: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].data.name == slotName) return i;\r\n        return -1;\r\n    },\r\n    setSkinByName: function (skinName)\r\n    {\r\n        var skin = this.data.findSkin(skinName);\r\n        if (!skin) throw \"Skin not found: \" + skinName;\r\n        this.setSkin(skin);\r\n    },\r\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\r\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was\r\n     * no old skin, each slot's setup mode attachment is attached from the new skin.\r\n     * @param newSkin May be null. */\r\n    setSkin: function (newSkin)\r\n    {\r\n        if (newSkin)\r\n        {\r\n            if (this.skin)\r\n                newSkin._attachAll(this, this.skin);\r\n            else\r\n            {\r\n                var slots = this.slots;\r\n                for (var i = 0, n = slots.length; i < n; i++)\r\n                {\r\n                    var slot = slots[i];\r\n                    var name = slot.data.attachmentName;\r\n                    if (name)\r\n                    {\r\n                        var attachment = newSkin.getAttachment(i, name);\r\n                        if (attachment) slot.setAttachment(attachment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        this.skin = newSkin;\r\n    },\r\n    /** @return May be null. */\r\n    getAttachmentBySlotName: function (slotName, attachmentName)\r\n    {\r\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\r\n    },\r\n    /** @return May be null. */\r\n    getAttachmentBySlotIndex: function (slotIndex, attachmentName)\r\n    {\r\n        if (this.skin)\r\n        {\r\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\r\n            if (attachment) return attachment;\r\n        }\r\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\r\n        return null;\r\n    },\r\n    /** @param attachmentName May be null. */\r\n    setAttachment: function (slotName, attachmentName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            var slot = slots[i];\r\n            if (slot.data.name == slotName)\r\n            {\r\n                var attachment = null;\r\n                if (attachmentName)\r\n                {\r\n                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);\r\n                    if (!attachment) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\r\n                }\r\n                slot.setAttachment(attachment);\r\n                return;\r\n            }\r\n        }\r\n        throw \"Slot not found: \" + slotName;\r\n    },\r\n    /** @return May be null. */\r\n    findIkConstraint: function (constraintName)\r\n    {\r\n        var constraints = this.ikConstraints;\r\n        for (var i = 0, n = constraints.length; i < n; i++)\r\n            if (constraints[i].data.name == constraintName) return constraints[i];\r\n        return null;\r\n    },\r\n    findTransformConstraint: function (constraintName)\r\n    {\r\n        var constraints = this.transformConstraints;\r\n        for (var i = 0, n = constraints.length; i < n; i++)\r\n            if (constraints[i].data.name == constraintName) return constraints[i];\r\n        return null;\r\n    },\r\n    update: function (delta)\r\n    {\r\n        this.time += delta;\r\n    },\r\n    resetDrawOrder: function () {\r\n        for (var i = 0, n = this.drawOrder.length; i < n; i++)\r\n        {\r\n            this.drawOrder[i] = i;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skeleton;\r\n\r\n","var spine = require('../SpineRuntime') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.SkeletonBounds = function ()\r\n{\r\n    this.polygonPool = [];\r\n    this.polygons = [];\r\n    this.boundingBoxes = [];\r\n};\r\nspine.SkeletonBounds.prototype = {\r\n    minX: 0, minY: 0, maxX: 0, maxY: 0,\r\n    update: function (skeleton, updateAabb)\r\n    {\r\n        var slots = skeleton.slots;\r\n        var slotCount = slots.length;\r\n        var x = skeleton.x, y = skeleton.y;\r\n        var boundingBoxes = this.boundingBoxes;\r\n        var polygonPool = this.polygonPool;\r\n        var polygons = this.polygons;\r\n\r\n        boundingBoxes.length = 0;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            polygonPool.push(polygons[i]);\r\n        polygons.length = 0;\r\n\r\n        for (var i = 0; i < slotCount; i++)\r\n        {\r\n            var slot = slots[i];\r\n            var boundingBox = slot.attachment;\r\n            if (boundingBox.type != spine.AttachmentType.boundingbox) continue;\r\n            boundingBoxes.push(boundingBox);\r\n\r\n            var poolCount = polygonPool.length, polygon;\r\n            if (poolCount > 0)\r\n            {\r\n                polygon = polygonPool[poolCount - 1];\r\n                polygonPool.splice(poolCount - 1, 1);\r\n            } else\r\n                polygon = [];\r\n            polygons.push(polygon);\r\n\r\n            polygon.length = boundingBox.vertices.length;\r\n            boundingBox.computeWorldVertices(x, y, slot.bone, polygon);\r\n        }\r\n\r\n        if (updateAabb) this.aabbCompute();\r\n    },\r\n    aabbCompute: function ()\r\n    {\r\n        var polygons = this.polygons;\r\n        var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n        {\r\n            var vertices = polygons[i];\r\n            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2)\r\n            {\r\n                var x = vertices[ii];\r\n                var y = vertices[ii + 1];\r\n                minX = Math.min(minX, x);\r\n                minY = Math.min(minY, y);\r\n                maxX = Math.max(maxX, x);\r\n                maxY = Math.max(maxY, y);\r\n            }\r\n        }\r\n        this.minX = minX;\r\n        this.minY = minY;\r\n        this.maxX = maxX;\r\n        this.maxY = maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box contains the point. */\r\n    aabbContainsPoint: function (x, y)\r\n    {\r\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\r\n    aabbIntersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\r\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\r\n            return false;\r\n        var m = (y2 - y1) / (x2 - x1);\r\n        var y = m * (minX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        y = m * (maxX - x1) + y1;\r\n        if (y > minY && y < maxY) return true;\r\n        var x = (minY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        x = (maxY - y1) / m + x1;\r\n        if (x > minX && x < maxX) return true;\r\n        return false;\r\n    },\r\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\r\n    aabbIntersectsSkeleton: function (bounds)\r\n    {\r\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\r\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\r\n    containsPoint: function (x, y)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually\r\n     * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */\r\n    intersectsSegment: function (x1, y1, x2, y2)\r\n    {\r\n        var polygons = this.polygons;\r\n        for (var i = 0, n = polygons.length; i < n; i++)\r\n            if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];\r\n        return null;\r\n    },\r\n    /** Returns true if the polygon contains the point. */\r\n    polygonContainsPoint: function (polygon, x, y)\r\n    {\r\n        var nn = polygon.length;\r\n        var prevIndex = nn - 2;\r\n        var inside = false;\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var vertexY = polygon[ii + 1];\r\n            var prevY = polygon[prevIndex + 1];\r\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y))\r\n            {\r\n                var vertexX = polygon[ii];\r\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;\r\n            }\r\n            prevIndex = ii;\r\n        }\r\n        return inside;\r\n    },\r\n    /** Returns true if the polygon contains the line segment. */\r\n    polygonIntersectsSegment: function (polygon, x1, y1, x2, y2)\r\n    {\r\n        var nn = polygon.length;\r\n        var width12 = x1 - x2, height12 = y1 - y2;\r\n        var det1 = x1 * y2 - y1 * x2;\r\n        var x3 = polygon[nn - 2], y3 = polygon[nn - 1];\r\n        for (var ii = 0; ii < nn; ii += 2)\r\n        {\r\n            var x4 = polygon[ii], y4 = polygon[ii + 1];\r\n            var det2 = x3 * y4 - y3 * x4;\r\n            var width34 = x3 - x4, height34 = y3 - y4;\r\n            var det3 = width12 * height34 - height12 * width34;\r\n            var x = (det1 * width34 - width12 * det2) / det3;\r\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1)))\r\n            {\r\n                var y = (det1 * height34 - height12 * det2) / det3;\r\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\r\n            }\r\n            x3 = x4;\r\n            y3 = y4;\r\n        }\r\n        return false;\r\n    },\r\n    getPolygon: function (attachment)\r\n    {\r\n        var index = this.boundingBoxes.indexOf(attachment);\r\n        return index == -1 ? null : this.polygons[index];\r\n    },\r\n    getWidth: function ()\r\n    {\r\n        return this.maxX - this.minX;\r\n    },\r\n    getHeight: function ()\r\n    {\r\n        return this.maxY - this.minY;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonBounds;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.SkeletonData = function ()\r\n{\r\n    this.bones = [];\r\n    this.slots = [];\r\n    this.skins = [];\r\n    this.events = [];\r\n    this.animations = [];\r\n    this.ikConstraints = [];\r\n    this.transformConstraints = [];\r\n};\r\nspine.SkeletonData.prototype = {\r\n    name: null,\r\n    defaultSkin: null,\r\n    width: 0, height: 0,\r\n    version: null, hash: null,\r\n    /** @return May be null. */\r\n    findBone: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].name == boneName) return bones[i];\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findBoneIndex: function (boneName)\r\n    {\r\n        var bones = this.bones;\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n            if (bones[i].name == boneName) return i;\r\n        return -1;\r\n    },\r\n    /** @return May be null. */\r\n    findSlot: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            if (slots[i].name == slotName) return this.slots[i];\r\n        }\r\n        return null;\r\n    },\r\n    /** @return -1 if the bone was not found. */\r\n    findSlotIndex: function (slotName)\r\n    {\r\n        var slots = this.slots;\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n            if (slots[i].name == slotName) return i;\r\n        return -1;\r\n    },\r\n    /** @return May be null. */\r\n    findSkin: function (skinName)\r\n    {\r\n        var skins = this.skins;\r\n        for (var i = 0, n = skins.length; i < n; i++)\r\n            if (skins[i].name == skinName) return skins[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findEvent: function (eventName)\r\n    {\r\n        var events = this.events;\r\n        for (var i = 0, n = events.length; i < n; i++)\r\n            if (events[i].name == eventName) return events[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findAnimation: function (animationName)\r\n    {\r\n        var animations = this.animations;\r\n        for (var i = 0, n = animations.length; i < n; i++)\r\n            if (animations[i].name == animationName) return animations[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findIkConstraint: function (constraintName)\r\n    {\r\n        var constraints = this.ikConstraints;\r\n        for (var i = 0, n = constraints.length; i < n; i++)\r\n            if (constraints[i].name == constraintName) return constraints[i];\r\n        return null;\r\n    },\r\n    /** @return May be null. */\r\n    findTransformConstraint: function (constraintName)\r\n    {\r\n        var constraints = this.transformConstraints;\r\n        for (var i = 0, n = constraints.length; i < n; i++)\r\n            if (constraints[i].name == constraintName) return constraints[i];\r\n        return null;\r\n    },\r\n};\r\nmodule.exports = spine.SkeletonData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.SkeletonData = require('./SkeletonData');\r\nspine.BoneData = require('./BoneData');\r\nspine.IkConstraintData = require('./IkConstraintData');\r\nspine.TransformConstraintData = require('./TransformConstraintData');\r\nspine.SlotData = require('./SlotData');\r\nspine.Skin = require('./Skin');\r\nspine.EventData = require('./EventData');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.ColorTimeline = require('./ColorTimeline');\r\nspine.AttachmentTimeline = require('./AttachmentTimeline');\r\nspine.RotateTimeline = require('./RotateTimeline');\r\nspine.ScaleTimeline = require('./ScaleTimeline');\r\nspine.TranslateTimeline = require('./TranslateTimeline');\r\nspine.ShearTimeline = require('./ShearTimeline');\r\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\r\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\r\nspine.FfdTimeline = require('./FfdTimeline');\r\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\r\nspine.EventTimeline = require('./EventTimeline');\r\nspine.Event = require('./Event');\r\nspine.Animation = require('./Animation');\r\n\r\nfunction LinkedMesh(mesh, skin, slotIndex, parent) {\r\n    this.mesh = mesh;\r\n    this.skin = skin;\r\n    this.slotIndex = slotIndex;\r\n    this.parent = parent;\r\n}\r\n\r\nspine.SkeletonJsonParser = function (attachmentLoader)\r\n{\r\n    if (attachmentLoader.pages) {\r\n        //its an atlas, we have to wrap it\r\n        this.attachmentLoader = new spine.AtlasAttachmentLoader(attachmentLoader);\r\n    } else {\r\n        //got a loader, thats good\r\n        this.attachmentLoader = attachmentLoader;\r\n    }\r\n    if (!attachmentLoader.newRegionAttachment) {\r\n        console.warn(\"SkeletonJsonParser accepts AtlasAttachmentLoader or atlas as first parameter\");\r\n    }\r\n    this.linkedMeshes = [];\r\n};\r\nspine.SkeletonJsonParser.prototype = {\r\n    scale: 1,\r\n    readSkeletonData: function (root, name)\r\n    {\r\n        var skeletonData = new spine.SkeletonData();\r\n        skeletonData.name = name;\r\n\r\n        var scale = this.scale;\r\n        // Skeleton.\r\n        var skeletonMap = root[\"skeleton\"];\r\n        if (skeletonMap)\r\n        {\r\n            skeletonData.hash = skeletonMap[\"hash\"];\r\n            skeletonData.version = skeletonMap[\"spine\"];\r\n            skeletonData.width = skeletonMap[\"width\"] || 0;\r\n            skeletonData.height = skeletonMap[\"height\"] || 0;\r\n        }\r\n\r\n        // Bones.\r\n        var bones = root[\"bones\"];\r\n        for (var i = 0, n = bones.length; i < n; i++)\r\n        {\r\n            var boneMap = bones[i];\r\n            var parent = null;\r\n            if (boneMap[\"parent\"])\r\n            {\r\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\r\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\r\n            }\r\n            var boneData = new spine.BoneData(boneMap[\"name\"], parent);\r\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\r\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\r\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\r\n            boneData.rotation = (boneMap[\"rotation\"] || 0);\r\n            boneData.scaleX = boneMap.hasOwnProperty(\"scaleX\") ? boneMap[\"scaleX\"] : 1;\r\n            boneData.scaleY = boneMap.hasOwnProperty(\"scaleY\") ? boneMap[\"scaleY\"] : 1;\r\n            boneData.shearX = boneMap[\"shearX\"] || 0;\r\n            boneData.shearY = boneMap[\"shearY\"] || 0;\r\n            boneData.inheritScale = boneMap.hasOwnProperty(\"inheritScale\") ? boneMap[\"inheritScale\"] : true;\r\n            boneData.inheritRotation = boneMap.hasOwnProperty(\"inheritRotation\") ? boneMap[\"inheritRotation\"] : true;\r\n            skeletonData.bones.push(boneData);\r\n        }\r\n\r\n        // IK constraints.\r\n        var ik = root[\"ik\"];\r\n        if (ik)\r\n        {\r\n            for (var i = 0, n = ik.length; i < n; i++)\r\n            {\r\n                var ikMap = ik[i];\r\n                var ikConstraintData = new spine.IkConstraintData(ikMap[\"name\"]);\r\n\r\n                var bones = ikMap[\"bones\"];\r\n                for (var ii = 0, nn = bones.length; ii < nn; ii++)\r\n                {\r\n                    var bone = skeletonData.findBone(bones[ii]);\r\n                    if (!bone) throw new Error( \"IK bone not found: \" + bones[ii] );\r\n                    ikConstraintData.bones.push(bone);\r\n                }\r\n\r\n                ikConstraintData.target = skeletonData.findBone(ikMap[\"target\"]);\r\n                if (!ikConstraintData.target) throw new Error(\"Target bone not found: \" + ikMap[\"target\"]);\r\n\r\n                ikConstraintData.bendDirection = (!ikMap.hasOwnProperty(\"bendPositive\") || ikMap[\"bendPositive\"]) ? 1 : -1;\r\n                ikConstraintData.mix = ikMap.hasOwnProperty(\"mix\") ? ikMap[\"mix\"] : 1;\r\n\r\n                skeletonData.ikConstraints.push(ikConstraintData);\r\n            }\r\n        }\r\n\r\n        var transform = root[\"transform\"];\r\n        if (transform) {\r\n            for (var i = 0, n = transform.length; i<n; i++) {\r\n                var transformMap = transform[i];\r\n                var transformData = new spine.TransformConstraintData(transformMap[\"name\"]);\r\n                transformData.bone = skeletonData.findBone(transformMap[\"bone\"]);\r\n                if (!transformData.bone) throw new Error(\"Transform bone not found: \" + transformData[\"bone\"]);\r\n                transformData.target = skeletonData.findBone(transformMap[\"target\"]);\r\n                if (!transformData.target) throw new Error(\"Target bone not found: \" + transformData[\"target\"]);\r\n\r\n                transformData.offsetRotation = transformMap[\"rotation\"] || 0;\r\n                transformData.offsetX = (transformMap[\"offsetX\"] || 0) * scale;\r\n                transformData.offsetY = (transformMap[\"offsetY\"] || 0) * scale;\r\n                transformData.offsetScaleX = (transformMap[\"scaleX\"] || 0) * scale;\r\n                transformData.offsetScaleY = (transformMap[\"scaleY\"] || 0) * scale;\r\n                transformData.offsetShearY = (transformMap[\"offsetShearY\"] || 0) * scale;\r\n\r\n                transformData.rotateMix = transformMap.hasOwnProperty(\"rotateMix\") ? transformMap[\"rotateMix\"] : 1;\r\n                transformData.translateMix = transformMap.hasOwnProperty(\"translateMix\") ? transformMap[\"translateMix\"] : 1;\r\n                transformData.scaleMix = transformMap.hasOwnProperty(\"scaleMix\") ? transformMap[\"scaleMix\"] : 1;\r\n                transformData.shearMix = transformMap.hasOwnProperty(\"shearMix\") ? transformMap[\"shearMix\"] : 1;\r\n\r\n                skeletonData.transformConstraints.push(transformData);\r\n            }\r\n        }\r\n\r\n        // Slots.\r\n        var slots = root[\"slots\"];\r\n        for (var i = 0, n = slots.length; i < n; i++)\r\n        {\r\n            var slotMap = slots[i];\r\n            var boneData = skeletonData.findBone(slotMap[\"bone\"]);\r\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\r\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\r\n\r\n            var color = slotMap[\"color\"];\r\n            if (color)\r\n            {\r\n                slotData.r = this.toColor(color, 0);\r\n                slotData.g = this.toColor(color, 1);\r\n                slotData.b = this.toColor(color, 2);\r\n                slotData.a = this.toColor(color, 3);\r\n            }\r\n\r\n            slotData.attachmentName = slotMap[\"attachment\"];\r\n\r\n\r\n            slotData.blendMode = slotMap[\"blend\"] && spine.SlotData.PIXI_BLEND_MODE_MAP[slotMap[\"blend\"]] || spine.SlotData.PIXI_BLEND_MODE_MAP['normal'];\r\n\r\n            skeletonData.slots.push(slotData);\r\n        }\r\n\r\n        // Skins.\r\n        var skins = root[\"skins\"];\r\n        for (var skinName in skins)\r\n        {\r\n            if (!skins.hasOwnProperty(skinName)) continue;\r\n            var skinMap = skins[skinName];\r\n            var skin = new spine.Skin(skinName);\r\n            for (var slotName in skinMap)\r\n            {\r\n                if (!skinMap.hasOwnProperty(slotName)) continue;\r\n                var slotIndex = skeletonData.findSlotIndex(slotName);\r\n                var slotEntry = skinMap[slotName];\r\n                for (var attachmentName in slotEntry)\r\n                {\r\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\r\n                    var attachment = this.readAttachment(skin, slotIndex, attachmentName, slotEntry[attachmentName]);\r\n                    if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);\r\n                }\r\n            }\r\n            skeletonData.skins.push(skin);\r\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\r\n        }\r\n\r\n        var linkedMeshes = this.linkedMeshes;\r\n        // Linked meshes.\r\n        for (var i = 0, n = linkedMeshes.size; i < n; i++) {\r\n            var linkedMesh = linkedMeshes[i];\r\n            var skin = linkedMesh.skin ? skeletonData.findSkin(linkedMesh.skin): skeletonData.defaultSkin;\r\n            var parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\r\n            linkedMesh.mesh.setParentMesh(parent);\r\n            linkedMesh.mesh.updateUVs();\r\n        }\r\n        linkedMeshes.length = 0;\r\n\r\n        // Events.\r\n        var events = root[\"events\"];\r\n        for (var eventName in events)\r\n        {\r\n            if (!events.hasOwnProperty(eventName)) continue;\r\n            var eventMap = events[eventName];\r\n            var eventData = new spine.EventData(eventName);\r\n            eventData.intValue = eventMap[\"int\"] || 0;\r\n            eventData.floatValue = eventMap[\"float\"] || 0;\r\n            eventData.stringValue = eventMap[\"string\"] || null;\r\n            skeletonData.events.push(eventData);\r\n        }\r\n\r\n        // Animations.\r\n        var animations = root[\"animations\"];\r\n        for (var animationName in animations)\r\n        {\r\n            if (!animations.hasOwnProperty(animationName)) continue;\r\n            this.readAnimation(animationName, animations[animationName], skeletonData);\r\n        }\r\n\r\n        return skeletonData;\r\n    },\r\n    readAttachment: function (skin, slotIndex, name, map)\r\n    {\r\n        name = map[\"name\"] || name;\r\n\r\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\r\n        var path = map[\"path\"] || name;\r\n\r\n        var scale = this.scale;\r\n        if (type == spine.AttachmentType.region)\r\n        {\r\n            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\r\n            if (!region) return null;\r\n            region.path = path;\r\n            region.x = (map[\"x\"] || 0) * scale;\r\n            region.y = (map[\"y\"] || 0) * scale;\r\n            region.scaleX = map.hasOwnProperty(\"scaleX\") ? map[\"scaleX\"] : 1;\r\n            region.scaleY = map.hasOwnProperty(\"scaleY\") ? map[\"scaleY\"] : 1;\r\n            region.rotation = map[\"rotation\"] || 0;\r\n            region.width = (map[\"width\"] || 0) * scale;\r\n            region.height = (map[\"height\"] || 0) * scale;\r\n\r\n            var color = map[\"color\"];\r\n            if (color)\r\n            {\r\n                region.r = this.toColor(color, 0);\r\n                region.g = this.toColor(color, 1);\r\n                region.b = this.toColor(color, 2);\r\n                region.a = this.toColor(color, 3);\r\n            }\r\n\r\n            region.updateOffset();\r\n            return region;\r\n        } else if (type == spine.AttachmentType.boundingbox)\r\n        {\r\n            var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\r\n            var vertices = map[\"vertices\"];\r\n            for (var i = 0, n = vertices.length; i < n; i++)\r\n                attachment.vertices.push(vertices[i] * scale);\r\n            return attachment;\r\n        } else if (type == spine.AttachmentType.mesh || type == spine.AttachmentType.linkedmesh ||\r\n            type == spine.AttachmentType.weightedmesh || type == spine.AttachmentType.weightedlinkedmesh)\r\n        {\r\n            var vertexCount = map[\"vertexCount\"] || 0;\r\n            if (vertexCount * 2 === map[\"vertices\"].length ||\r\n                map[\"vertices\"].length === map[\"uvs\"].length) {\r\n                //regular mesh\r\n                var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\r\n                if (!mesh) return null;\r\n                mesh.path = path;\r\n                color = map[\"color\"];\r\n                if (color) {\r\n                    mesh.r = this.toColor(color, 0);\r\n                    mesh.g = this.toColor(color, 1);\r\n                    mesh.b = this.toColor(color, 2);\r\n                    mesh.a = this.toColor(color, 3);\r\n                }\r\n                mesh.width = (map[\"width\"] || 0) * scale;\r\n                mesh.height = (map[\"height\"] || 0) * scale;\r\n\r\n                var parent = map[\"parent\"];\r\n                if (!parent) {\r\n                    mesh.vertices = this.getFloatArray(map, \"vertices\", scale);\r\n                    mesh.triangles = this.getIntArray(map, \"triangles\");\r\n                    mesh.regionUVs = this.getFloatArray(map, \"uvs\", 1);\r\n                    mesh.updateUVs();\r\n                    mesh.hullLength = (map[\"hull\"] || 0) * 2;\r\n                    if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\r\n                } else {\r\n                    mesh.inheritFFD = !!map[\"ffd\"];\r\n                    this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\r\n                }\r\n                return mesh;\r\n            } else {\r\n                //weighted mesh\r\n                var mesh = this.attachmentLoader.newWeightedMeshAttachment(skin, name, path);\r\n                if (!mesh) return null;\r\n                mesh.path = path;\r\n                color = map[\"color\"];\r\n                if (color) {\r\n                    mesh.r = this.toColor(color, 0);\r\n                    mesh.g = this.toColor(color, 1);\r\n                    mesh.b = this.toColor(color, 2);\r\n                    mesh.a = this.toColor(color, 3);\r\n                }\r\n                mesh.width = (map[\"width\"] || 0) * scale;\r\n                mesh.height = (map[\"height\"] || 0) * scale;\r\n\r\n                var parent = map[\"parent\"];\r\n                if (!parent) {\r\n                    var uvs = this.getFloatArray(map, \"uvs\", 1);\r\n                    var vertices = this.getFloatArray(map, \"vertices\", 1);\r\n                    var weights = [];\r\n                    var bones = [];\r\n                    for (var i = 0, n = vertices.length; i < n;) {\r\n                        var boneCount = vertices[i++] | 0;\r\n                        bones[bones.length] = boneCount;\r\n                        for (var nn = i + boneCount * 4; i < nn;) {\r\n                            bones[bones.length] = vertices[i];\r\n                            weights[weights.length] = vertices[i + 1] * scale;\r\n                            weights[weights.length] = vertices[i + 2] * scale;\r\n                            weights[weights.length] = vertices[i + 3];\r\n                            i += 4;\r\n                        }\r\n                    }\r\n                    mesh.bones = bones;\r\n                    mesh.weights = weights;\r\n                    mesh.triangles = this.getIntArray(map, \"triangles\");\r\n                    mesh.regionUVs = uvs;\r\n                    mesh.updateUVs();\r\n\r\n                    mesh.hullLength = (map[\"hull\"] || 0) * 2;\r\n                    if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\r\n                } else {\r\n                    mesh.inheritFFD = !!map[\"ffd\"];\r\n                    this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\r\n                }\r\n                return mesh;\r\n            }\r\n        }\r\n        throw \"Unknown attachment type: \" + type;\r\n    },\r\n    readAnimation: function (name, map, skeletonData)\r\n    {\r\n        var timelines = [];\r\n        var duration = 0;\r\n\r\n        var slots = map[\"slots\"];\r\n        for (var slotName in slots)\r\n        {\r\n            if (!slots.hasOwnProperty(slotName)) continue;\r\n            var slotMap = slots[slotName];\r\n            var slotIndex = skeletonData.findSlotIndex(slotName);\r\n\r\n            for (var timelineName in slotMap)\r\n            {\r\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\r\n                var values = slotMap[timelineName];\r\n                if (timelineName == \"color\")\r\n                {\r\n                    var timeline = new spine.ColorTimeline(values.length);\r\n                    timeline.slotIndex = slotIndex;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        var color = valueMap[\"color\"];\r\n                        var r = this.toColor(color, 0);\r\n                        var g = this.toColor(color, 1);\r\n                        var b = this.toColor(color, 2);\r\n                        var a = this.toColor(color, 3);\r\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\r\n                        this.readCurve(timeline, frameIndex, valueMap);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\r\n\r\n                } else if (timelineName == \"attachment\")\r\n                {\r\n                    var timeline = new spine.AttachmentTimeline(values.length);\r\n                    timeline.slotIndex = slotIndex;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n\r\n                } else\r\n                    throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\r\n            }\r\n        }\r\n\r\n        var bones = map[\"bones\"];\r\n        for (var boneName in bones)\r\n        {\r\n            if (!bones.hasOwnProperty(boneName)) continue;\r\n            var boneIndex = skeletonData.findBoneIndex(boneName);\r\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\r\n            var boneMap = bones[boneName];\r\n\r\n            for (var timelineName in boneMap)\r\n            {\r\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\r\n                var values = boneMap[timelineName];\r\n                if (timelineName == \"rotate\")\r\n                {\r\n                    var timeline = new spine.RotateTimeline(values.length);\r\n                    timeline.boneIndex = boneIndex;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\r\n                        this.readCurve(timeline, frameIndex, valueMap);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\r\n\r\n                } else if (timelineName == \"translate\" || timelineName == \"scale\" || timelineName == \"shear\")\r\n                {\r\n                    var timeline;\r\n                    var timelineScale = 1;\r\n                    if (timelineName == \"scale\") {\r\n                        timeline = new spine.ScaleTimeline(values.length);\r\n                    } else if (timelineName == \"shear\") {\r\n                        timeline = new spine.ShearTimeline(values.length);\r\n                    }\r\n                    else\r\n                    {\r\n                        timeline = new spine.TranslateTimeline(values.length);\r\n                        timelineScale = this.scale;\r\n                    }\r\n                    timeline.boneIndex = boneIndex;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\r\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\r\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\r\n                        this.readCurve(timeline, frameIndex, valueMap);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines.push(timeline);\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\r\n\r\n                } else if (timelineName == \"flipX\" || timelineName == \"flipY\")\r\n                {\r\n                    throw \"flipX and flipY are not supported in spine v3: (\" + boneName + \")\";\r\n                } else\r\n                    throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\r\n            }\r\n        }\r\n\r\n        var ikMap = map[\"ik\"];\r\n        for (var ikConstraintName in ikMap)\r\n        {\r\n            if (!ikMap.hasOwnProperty(ikConstraintName)) continue;\r\n            var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);\r\n            var values = ikMap[ikConstraintName];\r\n            var timeline = new spine.IkConstraintTimeline(values.length);\r\n            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);\r\n            var frameIndex = 0;\r\n            for (var i = 0, n = values.length; i < n; i++)\r\n            {\r\n                var valueMap = values[i];\r\n                var mix = valueMap.hasOwnProperty(\"mix\") ? valueMap[\"mix\"] : 1;\r\n                var bendDirection = (!valueMap.hasOwnProperty(\"bendPositive\") || valueMap[\"bendPositive\"]) ? 1 : -1;\r\n                timeline.setFrame(frameIndex, valueMap[\"time\"], mix, bendDirection);\r\n                this.readCurve(timeline, frameIndex, valueMap);\r\n                frameIndex++;\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\r\n        }\r\n\r\n        var transformMap = map[\"transform\"];\r\n        for (var transformConstraintName in transformMap)\r\n        {\r\n            if (!transformMap.hasOwnProperty(transformConstraintName)) continue;\r\n            var transformConstraint = skeletonData.findTransformConstraint(transformConstraintName);\r\n            var values = transformMap[transformConstraintName];\r\n            var timeline = new spine.TransformConstraintTimeline(values.length);\r\n            timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(transformConstraint);\r\n            var frameIndex = 0;\r\n            for (var i = 0, n = values.length; i < n; i++)\r\n            {\r\n                var valueMap = values[i];\r\n                var rotateMix = valueMap.hasOwnProperty(\"rotateMix\") ? valueMap[\"rotateMix\"] : 1;\r\n                var translateMix = valueMap.hasOwnProperty(\"translateMix\") ? valueMap[\"translateMix\"] : 1;\r\n                var scaleMix = valueMap.hasOwnProperty(\"scaleMix\") ? valueMap[\"scaleMix\"] : 1;\r\n                var shearMix = valueMap.hasOwnProperty(\"shearMix\") ? valueMap[\"shearMix\"] : 1;\r\n                timeline.setFrame(frameIndex, valueMap[\"time\"], translateMix, scaleMix, shearMix);\r\n                this.readCurve(timeline, frameIndex, valueMap);\r\n                frameIndex++;\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\r\n        }\r\n\r\n        var ffd = map[\"deform\"] || map[\"ffd\"];\r\n        for (var skinName in ffd)\r\n        {\r\n            var skin = skeletonData.findSkin(skinName);\r\n            var slotMap = ffd[skinName];\r\n            for (slotName in slotMap)\r\n            {\r\n                var slotIndex = skeletonData.findSlotIndex(slotName);\r\n                var meshMap = slotMap[slotName];\r\n                for (var meshName in meshMap)\r\n                {\r\n                    var values = meshMap[meshName];\r\n                    var timeline = new spine.FfdTimeline(values.length);\r\n                    var attachment = skin.getAttachment(slotIndex, meshName);\r\n                    if (!attachment) throw \"FFD attachment not found: \" + meshName;\r\n                    timeline.slotIndex = slotIndex;\r\n                    timeline.attachment = attachment;\r\n\r\n                    var isMesh = attachment.type == spine.AttachmentType.mesh;\r\n                    var vertexCount;\r\n                    if (isMesh)\r\n                        vertexCount = attachment.vertices.length;\r\n                    else\r\n                        vertexCount = attachment.weights.length / 3 * 2;\r\n\r\n                    var frameIndex = 0;\r\n                    for (var i = 0, n = values.length; i < n; i++)\r\n                    {\r\n                        var valueMap = values[i];\r\n                        var vertices;\r\n                        if (!valueMap[\"vertices\"])\r\n                        {\r\n                            if (isMesh)\r\n                                vertices = attachment.vertices;\r\n                            else\r\n                            {\r\n                                vertices = [];\r\n                                for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\r\n                            }\r\n                        } else {\r\n                            var verticesValue = valueMap[\"vertices\"];\r\n                            vertices = [];\r\n                            for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\r\n                            var start = valueMap[\"offset\"] || 0;\r\n                            var nn = verticesValue.length;\r\n                            if (this.scale == 1)\r\n                            {\r\n                                for (var ii = 0; ii < nn; ii++)\r\n                                    vertices[ii + start] = verticesValue[ii];\r\n                            } else {\r\n                                for (var ii = 0; ii < nn; ii++)\r\n                                    vertices[ii + start] = verticesValue[ii] * this.scale;\r\n                            }\r\n                            if (isMesh)\r\n                            {\r\n                                var meshVertices = attachment.vertices;\r\n                                for (var ii = 0, nn = vertices.length; ii < nn; ii++)\r\n                                    vertices[ii] += meshVertices[ii];\r\n                            }\r\n                        }\r\n\r\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], vertices);\r\n                        this.readCurve(timeline, frameIndex, valueMap);\r\n                        frameIndex++;\r\n                    }\r\n                    timelines[timelines.length] = timeline;\r\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        var drawOrderValues = map[\"drawOrder\"];\r\n        if (!drawOrderValues) drawOrderValues = map[\"draworder\"];\r\n        if (drawOrderValues)\r\n        {\r\n            var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);\r\n            var slotCount = skeletonData.slots.length;\r\n            var frameIndex = 0;\r\n            for (var i = 0, n = drawOrderValues.length; i < n; i++)\r\n            {\r\n                var drawOrderMap = drawOrderValues[i];\r\n                var drawOrder = null;\r\n                if (drawOrderMap[\"offsets\"])\r\n                {\r\n                    drawOrder = [];\r\n                    drawOrder.length = slotCount;\r\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\r\n                        drawOrder[ii] = -1;\r\n                    var offsets = drawOrderMap[\"offsets\"];\r\n                    var unchanged = [];\r\n                    unchanged.length = slotCount - offsets.length;\r\n                    var originalIndex = 0, unchangedIndex = 0;\r\n                    for (var ii = 0, nn = offsets.length; ii < nn; ii++)\r\n                    {\r\n                        var offsetMap = offsets[ii];\r\n                        var slotIndex = skeletonData.findSlotIndex(offsetMap[\"slot\"]);\r\n                        if (slotIndex == -1) throw \"Slot not found: \" + offsetMap[\"slot\"];\r\n                        // Collect unchanged items.\r\n                        while (originalIndex != slotIndex)\r\n                            unchanged[unchangedIndex++] = originalIndex++;\r\n                        // Set changed items.\r\n                        drawOrder[originalIndex + offsetMap[\"offset\"]] = originalIndex++;\r\n                    }\r\n                    // Collect remaining unchanged items.\r\n                    while (originalIndex < slotCount)\r\n                        unchanged[unchangedIndex++] = originalIndex++;\r\n                    // Fill in unchanged items.\r\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\r\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\r\n                }\r\n                timeline.setFrame(frameIndex++, drawOrderMap[\"time\"], drawOrder);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        var events = map[\"events\"];\r\n        if (events)\r\n        {\r\n            var timeline = new spine.EventTimeline(events.length);\r\n            var frameIndex = 0;\r\n            for (var i = 0, n = events.length; i < n; i++)\r\n            {\r\n                var eventMap = events[i];\r\n                var eventData = skeletonData.findEvent(eventMap[\"name\"]);\r\n                if (!eventData) throw \"Event not found: \" + eventMap[\"name\"];\r\n                var event = new spine.Event(eventData);\r\n                event.intValue = eventMap.hasOwnProperty(\"int\") ? eventMap[\"int\"] : eventData.intValue;\r\n                event.floatValue = eventMap.hasOwnProperty(\"float\") ? eventMap[\"float\"] : eventData.floatValue;\r\n                event.stringValue = eventMap.hasOwnProperty(\"string\") ? eventMap[\"string\"] : eventData.stringValue;\r\n                timeline.setFrame(frameIndex++, eventMap[\"time\"], event);\r\n            }\r\n            timelines.push(timeline);\r\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\r\n        }\r\n\r\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\r\n    },\r\n    readCurve: function (timeline, frameIndex, valueMap)\r\n    {\r\n        var curve = valueMap[\"curve\"];\r\n        if (!curve)\r\n            timeline.curves.setLinear(frameIndex);\r\n        else if (curve == \"stepped\")\r\n            timeline.curves.setStepped(frameIndex);\r\n        else if (curve instanceof Array)\r\n            timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\r\n    },\r\n    toColor: function (hexString, colorIndex)\r\n    {\r\n        if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\r\n        return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;\r\n    },\r\n    getFloatArray: function (map, name, scale)\r\n    {\r\n        var list = map[name];\r\n        var values = new spine.Float32Array(list.length);\r\n        var i = 0, n = list.length;\r\n        if (scale == 1)\r\n        {\r\n            for (; i < n; i++)\r\n                values[i] = list[i];\r\n        } else {\r\n            for (; i < n; i++)\r\n                values[i] = list[i] * scale;\r\n        }\r\n        return values;\r\n    },\r\n    getIntArray: function (map, name)\r\n    {\r\n        var list = map[name];\r\n        var values = new spine.Uint16Array(list.length);\r\n        for (var i = 0, n = list.length; i < n; i++)\r\n            values[i] = list[i] | 0;\r\n        return values;\r\n    }\r\n};\r\nmodule.exports = spine.SkeletonJsonParser;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Skin = function (name)\r\n{\r\n    this.name = name;\r\n    this.attachments = {};\r\n};\r\nspine.Skin.prototype = {\r\n    addAttachment: function (slotIndex, name, attachment)\r\n    {\r\n        this.attachments[slotIndex + \":\" + name] = attachment;\r\n    },\r\n    getAttachment: function (slotIndex, name)\r\n    {\r\n        return this.attachments[slotIndex + \":\" + name];\r\n    },\r\n    _attachAll: function (skeleton, oldSkin)\r\n    {\r\n        for (var key in oldSkin.attachments)\r\n        {\r\n            var colon = key.indexOf(\":\");\r\n            var slotIndex = parseInt(key.substring(0, colon));\r\n            var name = key.substring(colon + 1);\r\n            var slot = skeleton.slots[slotIndex];\r\n            if (slot.attachment && slot.attachment.name == name)\r\n            {\r\n                var attachment = this.getAttachment(slotIndex, name);\r\n                if (attachment) slot.setAttachment(attachment);\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Skin;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Slot = function (slotData, bone)\r\n{\r\n    this.data = slotData;\r\n    this.bone = bone;\r\n    this.setToSetupPose();\r\n};\r\nspine.Slot.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    _attachmentTime: 0,\r\n    attachment: null,\r\n    attachmentVertices: [],\r\n    setAttachment: function (attachment)\r\n    {\r\n        this.attachment = attachment;\r\n        this._attachmentTime = this.bone.skeleton.time;\r\n        this.attachmentVertices.length = 0;\r\n    },\r\n    setAttachmentTime: function (time)\r\n    {\r\n        this._attachmentTime = this.bone.skeleton.time - time;\r\n    },\r\n    getAttachmentTime: function ()\r\n    {\r\n        return this.bone.skeleton.time - this._attachmentTime;\r\n    },\r\n    setToSetupPose: function ()\r\n    {\r\n        var data = this.data;\r\n        this.r = data.r;\r\n        this.g = data.g;\r\n        this.b = data.b;\r\n        this.a = data.a;\r\n        this.blendMode = data.blendMode;\r\n\r\n        var slotDatas = this.bone.skeleton.data.slots;\r\n        for (var i = 0, n = slotDatas.length; i < n; i++)\r\n        {\r\n            if (slotDatas[i] == data)\r\n            {\r\n                this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\r\n                break;\r\n            }\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.Slot;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.SlotData = function (name, boneData)\r\n{\r\n    this.name = name;\r\n    this.boneData = boneData;\r\n};\r\n\r\nspine.SlotData.PIXI_BLEND_MODE_MAP = {\r\n    'multiply': PIXI.BLEND_MODES.MULTIPLY,\r\n    'screen': PIXI.BLEND_MODES.SCREEN,\r\n    'additive': PIXI.BLEND_MODES.ADD,\r\n    'normal': PIXI.BLEND_MODES.NORMAL\r\n};\r\n\r\nspine.SlotData.prototype = {\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    attachmentName: null,\r\n    blendMode: PIXI.BLEND_MODES.NORMAL\r\n\r\n\r\n};\r\n\r\n\r\nmodule.exports = spine.SlotData;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.TrackEntry = function ()\r\n{};\r\nspine.TrackEntry.prototype = {\r\n    next: null, previous: null,\r\n    animation: null,\r\n    loop: false,\r\n    delay: 0, time: 0, lastTime: -1, endTime: 0,\r\n    timeScale: 1,\r\n    mixTime: 0, mixDuration: 0, mix: 1,\r\n    onStart: null, onEnd: null, onComplete: null, onEvent: null\r\n};\r\nmodule.exports = spine.TrackEntry;\r\n\r\n","var spine = require('../SpineUtil');\r\nvar tempVec = [0, 0];\r\nspine.TransformConstraint = function (data, skeleton)\r\n{\r\n    this.data = data;\r\n    this.translateMix = data.translateMix;\r\n    this.rotateMix = data.rotateMix;\r\n    this.scaleMix = data.scaleMix;\r\n    this.shearMix = data.shearMix;\r\n    this.offsetX = data.offsetX;\r\n    this.offsetY = data.offsetY;\r\n    this.offsetScaleX = data.offsetScaleX;\r\n    this.offsetScaleY = data.offsetScaleY;\r\n    this.offsetShearY = data.offsetShearY;\r\n\r\n    this.bone = skeleton.findBone(data.bone.name);\r\n    this.target = skeleton.findBone(data.target.name);\r\n};\r\n\r\nspine.TransformConstraint.prototype = {\r\n    update: function() {\r\n        this.apply();\r\n    },\r\n    apply: function ()\r\n    {\r\n        var bm = this.bone.matrix;\r\n        var tm = this.target.matrix;\r\n\r\n        var rotateMix = this.rotateMix;\r\n        if (rotateMix > 0) {\r\n            var a = bm.a, b = bm.c, c = bm.b, d = bm.d;\r\n            var r = Math.atan2(tm.b, tm.a) - Math.atan2(c, a);\r\n            if (r > Math.PI)\r\n                r -= Math.PI*2;\r\n            else if (r < -Math.PI) r += Math.PI*2;\r\n            r *= rotateMix;\r\n            var cos = Math.cos(r), sin = Math.sin(r);\r\n            bm.a = cos * a - sin * c;\r\n            bm.c = cos * b - sin * d;\r\n            bm.b = sin * a + cos * c;\r\n            bm.d = sin * b + cos * d;\r\n        }\r\n\r\n        var scaleMix = this.rotateMix;\r\n        if (scaleMix > 0) {\r\n            var bs = Math.sqrt(bm.a * bm.a + bm.b * bm.b);\r\n            var ts = Math.sqrt(tm.a * tm.a + tm.b * tm.b);\r\n            var s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleX) * scaleMix) / bs : 0;\r\n            bm.a *= s;\r\n            bm.b *= s;\r\n            bs = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\r\n            ts = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\r\n            s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleY) * scaleMix) / bs : 0;\r\n            bm.c *= s;\r\n            bm.d *= s;\r\n        }\r\n\r\n        var shearMix = this.shearMix;\r\n        if (shearMix > 0) {\r\n            var b = bm.c, d = bm.d;\r\n            var by = Math.atan2(d, b);\r\n            var r = Math.atan2(tm.d, tm.c) - Math.atan2(tm.b, target.a) - (by - Math.atan2(bm.b, bm.a));\r\n            if (r > Math.PI)\r\n                r -= Math.PI*2;\r\n            else if (r < -Math.PI) r += Math.PI*2;\r\n            r = by + (r + this.offsetShearY * spine.degRad) * shearMix;\r\n            var s = Math.sqrt(b * b + d * d);\r\n            bm.c = Math.cos(r) * s;\r\n            bm.d = Math.sin(r) * s;\r\n        }\r\n\r\n        var translateMix = this.translateMix;\r\n        if (translateMix > 0) {\r\n            tempVec[0] = this.offsetX;\r\n            tempVec[1] = this.offsetY;\r\n            this.target.localToWorld(tempVec);\r\n            bm.tx += (tempVec[0] - bm.tx) * translateMix;\r\n            bm.ty += (tempVec[1] - bm.ty) * translateMix;\r\n        }\r\n    }\r\n};\r\n\r\nmodule.exports = spine.TransformConstraint;\r\n","var spine = require('../SpineUtil') || {};\r\nspine.TransformConstraintData = function (name)\r\n{\r\n    this.name = name;\r\n    this.bone = null;\r\n};\r\nspine.TransformConstraintData.prototype = {\r\n    target: null,\r\n    rotateMix: 1,\r\n    translateMix: 1,\r\n    scaleMix: 1,\r\n    shearMix: 1,\r\n    offsetRotation: 0,\r\n    offsetX: 0,\r\n    offsetY: 0,\r\n    offsetScaleX: 0,\r\n    offsetScaleY: 0,\r\n    offsetShearY: 0\r\n};\r\nmodule.exports = spine.TransformConstraintData;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.TransformConstraintTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, mix, bendDirection, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.TransformConstraintTimeline.prototype = {\r\n    transformConstraintIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 5;\r\n    },\r\n    setFrame: function (frameIndex, time, rotateMix, translateMix, scaleMix, shareMix)\r\n    {\r\n        frameIndex *= 5;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = rotateMix;\r\n        this.frames[frameIndex + 2] = translateMix;\r\n        this.frames[frameIndex + 3] = scaleMix;\r\n        this.frames[frameIndex + 4] = shareMix;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\r\n\r\n        if (time >= frames[frames.length - 5])\r\n        { // Time is after last frame.\r\n            constraint.rotateMix += (frames[i - 3] - constraint.rotateMix) * alpha;\r\n            constraint.translateMix += (frames[i - 2] - constraint.translateMix) * alpha;\r\n            constraint.scaleMix += (frames[i - 1] - constraint.scaleMix) * alpha;\r\n            constraint.shearMix += (frames[i] - constraint.shearMix) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frame = spine.Animation.binarySearch(frames, time, 5);\r\n        var frameTime = frames[frame];\r\n        var percent = 1 - (time - frameTime) / (frames[frame + -5/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frame / 5 - 1, percent);\r\n\r\n        var rotate = frames[frame + -4/*PREV_ROTATE_MIX*/];\r\n        var translate = frames[frame + -3/*PREV_TRANSLATE_MIX*/];\r\n        var scale = frames[frame + -2/*PREV_SCALE_MIX*/];\r\n        var shear = frames[frame + -1/*PREV_SHEAR_MIX*/];\r\n        constraint.rotateMix += (rotate + (frames[frame + 1/*ROTATE_MIX*/] - rotate) * percent - constraint.rotateMix) * alpha;\r\n        constraint.translateMix += (translate + (frames[frame + 2/*TRANSLATE_MIX*/] - translate) * percent - constraint.translateMix)\r\n            * alpha;\r\n        constraint.scaleMix += (scale + (frames[frame + 3/*SCALE_MIX*/] - scale) * percent - constraint.scaleMix) * alpha;\r\n        constraint.shearMix += (shear + (frames[frame + 4/*SHEAR_MIX*/] - shear) * percent - constraint.shearMix) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.TransformConstraintTimeline;\r\n\r\n","var spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.Curves = require('./Curves');\r\nspine.TranslateTimeline = function (frameCount)\r\n{\r\n    this.curves = new spine.Curves(frameCount);\r\n    this.frames = []; // time, x, y, ...\r\n    this.frames.length = frameCount * 3;\r\n};\r\nspine.TranslateTimeline.prototype = {\r\n    boneIndex: 0,\r\n    getFrameCount: function ()\r\n    {\r\n        return this.frames.length / 3;\r\n    },\r\n    setFrame: function (frameIndex, time, x, y)\r\n    {\r\n        frameIndex *= 3;\r\n        this.frames[frameIndex] = time;\r\n        this.frames[frameIndex + 1] = x;\r\n        this.frames[frameIndex + 2] = y;\r\n    },\r\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\r\n    {\r\n        var frames = this.frames;\r\n        if (time < frames[0]) return; // Time is before first frame.\r\n\r\n        var bone = skeleton.bones[this.boneIndex];\r\n\r\n        if (time >= frames[frames.length - 3])\r\n        { // Time is after last frame.\r\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\r\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\r\n            return;\r\n        }\r\n\r\n        // Interpolate between the previous frame and the current frame.\r\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\r\n        var prevFrameX = frames[frameIndex - 2];\r\n        var prevFrameY = frames[frameIndex - 1];\r\n        var frameTime = frames[frameIndex];\r\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\r\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\r\n\r\n        bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;\r\n        bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;\r\n    }\r\n};\r\nmodule.exports = spine.TranslateTimeline;\r\n\r\n","var spine = require('../SpineUtil') || {};\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.WeightedMeshAttachment = function (name)\r\n{\r\n    this.name = name;\r\n};\r\nspine.WeightedMeshAttachment.prototype = {\r\n    type: spine.AttachmentType.weightedmesh,\r\n    parentMesh: null,\r\n    inheritFFD: false,\r\n    bones: null,\r\n    weights: null,\r\n    uvs: null,\r\n    regionUVs: null,\r\n    triangles: null,\r\n    hullLength: 0,\r\n    r: 1, g: 1, b: 1, a: 1,\r\n    path: null,\r\n    rendererObject: null,\r\n    edges: null,\r\n    width: 0, height: 0,\r\n    updateUVs: function (u, v, u2, v2, rotate)\r\n    {\r\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\r\n        var n = this.regionUVs.length;\r\n        if (!this.uvs || this.uvs.length != n)\r\n        {\r\n            this.uvs = new spine.Float32Array(n);\r\n        }\r\n        var region = this.rendererObject;\r\n        if (!region) return;\r\n        var texture = region.texture;\r\n        var r = texture._uvs;\r\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\r\n        var x = region.offsetX, y = region.pixiOffsetY;\r\n        for (var i = 0; i < n; i += 2)\r\n        {\r\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\r\n            u = (u * w2 - x) / w1;\r\n            v = (v * h2 - y) / h1;\r\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\r\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\r\n        }\r\n    },\r\n    computeWorldVertices: function (x, y, slot, worldVertices)\r\n    {\r\n        var skeletonBones = slot.bone.skeleton.bones;\r\n        var weights = this.weights;\r\n        var bones = this.bones;\r\n\r\n        var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;\r\n        var wx, wy, vx, vy, weight;\r\n        var m;\r\n        if (!slot.attachmentVertices.length)\r\n        {\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3)\r\n                {\r\n                    m = skeletonBones[bones[v]].matrix;\r\n                    vx = weights[b];\r\n                    vy = weights[b + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\r\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        } else {\r\n            var ffd = slot.attachmentVertices;\r\n            for (; v < n; w += 2)\r\n            {\r\n                wx = 0;\r\n                wy = 0;\r\n                nn = bones[v++] + v;\r\n                for (; v < nn; v++, b += 3, f += 2)\r\n                {\r\n                    m = skeletonBones[bones[v]].matrix;\r\n                    vx = weights[b] + ffd[f];\r\n                    vy = weights[b + 1] + ffd[f + 1];\r\n                    weight = weights[b + 2];\r\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\r\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\r\n                }\r\n                worldVertices[w] = wx + x;\r\n                worldVertices[w + 1] = wy + y;\r\n            }\r\n        }\r\n    },\r\n    applyFFD: function(sourceAttachment) {\r\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\r\n    },\r\n    setParentMesh: function(parentMesh) {\r\n        this.parentMesh = parentMesh;\r\n        if (parentMesh != null) {\r\n            this.bones = parentMesh.bones;\r\n            this.weights = parentMesh.weights;\r\n            this.regionUVs = parentMesh.regionUVs;\r\n            this.triangles = parentMesh.triangles;\r\n            this.hullLength = parentMesh.hullLength;\r\n        }\r\n    }\r\n};\r\nmodule.exports = spine.WeightedMeshAttachment;\r\n\r\n","/******************************************************************************\r\n * Spine Runtimes Software License\r\n * Version 2.1\r\n *\r\n * Copyright (c) 2013, Esoteric Software\r\n * All rights reserved.\r\n *\r\n * You are granted a perpetual, non-exclusive, non-sublicensable and\r\n * non-transferable license to install, execute and perform the Spine Runtimes\r\n * Software (the \"Software\") solely for internal use. Without the written\r\n * permission of Esoteric Software (typically granted by licensing Spine), you\r\n * may not (a) modify, translate, adapt or otherwise create derivative works,\r\n * improvements of the Software or develop new applications using the Software\r\n * or (b) remove, delete, alter or obscure any trademarks or any copyright,\r\n * trademark, patent or other intellectual property or proprietary rights\r\n * notices on or in the Software, including any copy thereof. Redistributions\r\n * in binary or source form must include this license and terms.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\r\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\r\n * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\r\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\r\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\r\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\r\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *****************************************************************************/\r\nvar spine = require('../SpineUtil');\r\nspine.Animation = require('./Animation');\r\nspine.AnimationStateData = require('./AnimationStateData');\r\nspine.AnimationState = require('./AnimationState');\r\nspine.AtlasAttachmentParser = require('./AtlasAttachmentParser');\r\nspine.Atlas = require('./Atlas');\r\nspine.AtlasPage = require('./AtlasPage');\r\nspine.AtlasReader = require('./AtlasReader');\r\nspine.AtlasRegion = require('./AtlasRegion');\r\nspine.AttachmentTimeline = require('./AttachmentTimeline');\r\nspine.AttachmentType = require('./AttachmentType');\r\nspine.BoneData = require('./BoneData');\r\nspine.Bone = require('./Bone');\r\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\r\nspine.ColorTimeline = require('./ColorTimeline');\r\nspine.Curves = require('./Curves');\r\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\r\nspine.EventData = require('./EventData');\r\nspine.Event = require('./Event');\r\nspine.EventTimeline = require('./EventTimeline');\r\nspine.FfdTimeline = require('./FfdTimeline');\r\nspine.IkConstraintData = require('./IkConstraintData');\r\nspine.IkConstraint = require('./IkConstraint');\r\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\r\nspine.TransformConstraintData = require('./TransformConstraintData');\r\nspine.TransformConstraint = require('./TransformConstraint');\r\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\r\nspine.MeshAttachment = require('./MeshAttachment');\r\nspine.RegionAttachment = require('./RegionAttachment');\r\nspine.RotateTimeline = require('./RotateTimeline');\r\nspine.ScaleTimeline = require('./ScaleTimeline');\r\nspine.ShearTimeline = require('./ShearTimeline');\r\nspine.SkeletonBounds = require('./SkeletonBounds');\r\nspine.SkeletonData = require('./SkeletonData');\r\nspine.Skeleton = require('./Skeleton');\r\nspine.SkeletonJsonParser = require('./SkeletonJsonParser');\r\nspine.Skin = require('./Skin.js');\r\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\r\nspine.SlotData = require('./SlotData');\r\nspine.Slot = require('./Slot');\r\nspine.TrackEntry = require('./TrackEntry');\r\nspine.TranslateTimeline = require('./TranslateTimeline');\r\nmodule.exports = spine;\r\n","module.exports = {\r\n    radDeg: 180 / Math.PI,\r\n    degRad: Math.PI / 180,\r\n    temp: [],\r\n    Float32Array: (typeof(Float32Array) === 'undefined') ? Array : Float32Array,\r\n    Uint16Array: (typeof(Uint16Array) === 'undefined') ? Array : Uint16Array,\r\n    signum: function(x) {\r\n        if (x>0) return 1;\r\n        if (x<0) return -1;\r\n        return 0;\r\n    }\r\n};\r\n\r\n","var spine = require('../SpineRuntime');\r\nvar atlasParser = require('../loaders/atlasParser');\r\nvar TransformBase = PIXI.TransformBase || PIXI.TransformManual;\r\n\r\n/* Esoteric Software SPINE wrapper for pixi.js */\r\nspine.Bone.yDown = true;\r\n\r\n/**\r\n * A class that enables the you to import and run your spine animations in pixi.\r\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\r\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\r\n *\r\n * ```js\r\n * var spineAnimation = new PIXI.Spine(spineData);\r\n * ```\r\n *\r\n * @class\r\n * @extends Container\r\n * @memberof PIXI.spine\r\n * @param spineData {object} The spine data loaded from a spine atlas.\r\n */\r\nfunction Spine(spineData)\r\n{\r\n    PIXI.Container.call(this);\r\n\r\n    if (!spineData)\r\n    {\r\n        throw new Error('The spineData param is required.');\r\n    }\r\n\r\n    if ((typeof spineData) === \"string\")\r\n    {\r\n        throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\r\n    }\r\n\r\n    /**\r\n     * The spineData object\r\n     *\r\n     * @member {object}\r\n     */\r\n    this.spineData = spineData;\r\n\r\n    /**\r\n     * A spine Skeleton object\r\n     *\r\n     * @member {object}\r\n     */\r\n    this.skeleton = new spine.Skeleton(spineData);\r\n    this.skeleton.updateWorldTransform();\r\n\r\n    /**\r\n     * A spine AnimationStateData object created from the spine data passed in the constructor\r\n     *\r\n     * @member {object}\r\n     */\r\n    this.stateData = new spine.AnimationStateData(spineData);\r\n\r\n    /**\r\n     * A spine AnimationState object created from the spine AnimationStateData object\r\n     *\r\n     * @member {object}\r\n     */\r\n    this.state = new spine.AnimationState(this.stateData);\r\n\r\n    /**\r\n     * An array of containers\r\n     *\r\n     * @member {Container[]}\r\n     */\r\n    this.slotContainers = [];\r\n\r\n    for (var i = 0, n = this.skeleton.slots.length; i < n; i++)\r\n    {\r\n        var slot = this.skeleton.slots[i];\r\n        var attachment = slot.attachment;\r\n        var slotContainer = new PIXI.Container();\r\n        this.slotContainers.push(slotContainer);\r\n        this.addChild(slotContainer);\r\n\r\n        if (attachment instanceof spine.RegionAttachment)\r\n        {\r\n            var spriteName = attachment.rendererObject.name;\r\n            var sprite = this.createSprite(slot, attachment);\r\n            slot.currentSprite = sprite;\r\n            slot.currentSpriteName = spriteName;\r\n            slotContainer.addChild(sprite);\r\n        }\r\n        else if (attachment instanceof spine.MeshAttachment)\r\n        {\r\n            var mesh = this.createMesh(slot, attachment);\r\n            slot.currentMesh = mesh;\r\n            slot.currentMeshName = attachment.name;\r\n            slotContainer.addChild(mesh);\r\n        }\r\n        else\r\n        {\r\n            continue;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Should the Spine object update its transforms\r\n     *\r\n     * @member {boolean}\r\n     */\r\n    this.autoUpdate = true;\r\n\r\n    /**\r\n     * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\r\n     *\r\n     * @member {number}\r\n     * @memberof PIXI.spine.Spine#\r\n     */\r\n    this.tintRgb = new Float32Array([1, 1, 1]);\r\n}\r\n\r\nSpine.fromAtlas = function(resourceName) {\r\n    var skeletonData = atlasParser.AnimCache[resourceName];\r\n\r\n    if (!skeletonData)\r\n    {\r\n        throw new Error('Spine data \"' + resourceName + '\" does not exist in the animation cache');\r\n    }\r\n\r\n    return new Spine(skeletonData);\r\n}\r\n\r\nSpine.prototype = Object.create(PIXI.Container.prototype);\r\nSpine.prototype.constructor = Spine;\r\nmodule.exports = Spine;\r\n\r\nSpine.globalAutoUpdate = true;\r\n\r\nObject.defineProperties(Spine.prototype, {\r\n    /**\r\n     * If this flag is set to true, the spine animation will be autoupdated every time\r\n     * the object id drawn. The down side of this approach is that the delta time is\r\n     * automatically calculated and you could miss out on cool effects like slow motion,\r\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\r\n     * autoupdate enabled but are harder to achieve.\r\n     *\r\n     * @member {boolean}\r\n     * @memberof PIXI.spine.Spine#\r\n     * @default true\r\n     */\r\n    autoUpdate: {\r\n        get: function ()\r\n        {\r\n            return (this.updateTransform === Spine.prototype.autoUpdateTransform);\r\n        },\r\n\r\n        set: function (value)\r\n        {\r\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\r\n        }\r\n    },\r\n    /**\r\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\r\n     *\r\n     * @member {number}\r\n     * @memberof PIXI.spine.Spine#\r\n     * @default 0xFFFFFF\r\n     */\r\n    tint: {\r\n        get: function() {\r\n            return PIXI.utils.rgb2hex(this.tintRgb);\r\n        },\r\n        set: function(value) {\r\n            this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb);\r\n        }\r\n    }\r\n});\r\n\r\nvar tempRgb = [0, 0, 0];\r\n\r\n/**\r\n * Update the spine skeleton and its animations by delta time (dt)\r\n *\r\n * @param dt {number} Delta time. Time by which the animation should be updated\r\n */\r\nSpine.prototype.update = function (dt)\r\n{\r\n    this.state.update(dt);\r\n    this.state.apply(this.skeleton);\r\n    this.skeleton.updateWorldTransform();\r\n\r\n    var drawOrder = this.skeleton.drawOrder;\r\n    var slots = this.skeleton.slots;\r\n\r\n    for (var i = 0, n = drawOrder.length; i < n; i++)\r\n    {\r\n        this.children[i] = this.slotContainers[drawOrder[i]];\r\n    }\r\n\r\n    var r0 = this.tintRgb[0];\r\n    var g0 = this.tintRgb[1];\r\n    var b0 = this.tintRgb[2];\r\n\r\n    for (i = 0, n = slots.length; i < n; i++)\r\n    {\r\n        var slot = slots[i];\r\n        var attachment = slot.attachment;\r\n        var slotContainer = this.slotContainers[i];\r\n\r\n        if (!attachment)\r\n        {\r\n            slotContainer.visible = false;\r\n            continue;\r\n        }\r\n\r\n        var type = attachment.type;\r\n        if (type === spine.AttachmentType.region)\r\n        {\r\n            if (attachment.rendererObject)\r\n            {\r\n                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name)\r\n                {\r\n                    var spriteName = attachment.rendererObject.name;\r\n                    if (slot.currentSprite !== undefined)\r\n                    {\r\n                        slot.currentSprite.visible = false;\r\n                    }\r\n                    slot.sprites = slot.sprites || {};\r\n                    if (slot.sprites[spriteName] !== undefined)\r\n                    {\r\n                        slot.sprites[spriteName].visible = true;\r\n                    }\r\n                    else\r\n                    {\r\n                        var sprite = this.createSprite(slot, attachment);\r\n                        slotContainer.addChild(sprite);\r\n                    }\r\n                    slot.currentSprite = slot.sprites[spriteName];\r\n                    slot.currentSpriteName = spriteName;\r\n                }\r\n            }\r\n\r\n            if (slotContainer.transform ) {\r\n                var transform = slotContainer.transform;\r\n                var lt;\r\n                if (slotContainer.transform.matrix2d) {\r\n                    //gameofbombs pixi fork\r\n                    lt = transform.matrix2d;\r\n                    transform._dirtyVersion++;\r\n                    transform.version = transform._dirtyVersion;\r\n                    transform.isStatic = true;\r\n                    transform.operMode = 0;\r\n                } else {\r\n                    if (TransformBase) {\r\n                        //PIXI v4.0\r\n                        if (transform.position) {\r\n                            transform = new PIXI.TransformBase();\r\n                            slotContainer.transform = transform;\r\n                        }\r\n                        lt = transform.localTransform;\r\n                    } else {\r\n                        //PIXI v4.0rc\r\n                        if (!transform._dirtyLocal) {\r\n                            transform = new PIXI.TransformStatic();\r\n                            slotContainer.transform = transform;\r\n                        }\r\n                        lt = transform.localTransform;\r\n                        transform._dirtyParentVersion = -1;\r\n                        transform._dirtyLocal = 1;\r\n                        transform._versionLocal = 1;\r\n                    }\r\n                }\r\n                slot.bone.matrix.copy(lt);\r\n                lt.tx += slot.bone.skeleton.x;\r\n                lt.ty += slot.bone.skeleton.y;\r\n            } else {\r\n                //PIXI v3\r\n                var lt = slotContainer.localTransform || new PIXI.Matrix();\r\n                slot.bone.matrix.copy(lt);\r\n                lt.tx += slot.bone.skeleton.x;\r\n                lt.ty += slot.bone.skeleton.y;\r\n                slotContainer.localTransform = lt;\r\n                slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\r\n            }\r\n            tempRgb[0] = r0 * slot.r * attachment.r;\r\n            tempRgb[1] = g0 * slot.g * attachment.g;\r\n            tempRgb[2] = b0 * slot.b * attachment.b;\r\n            slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\r\n            slot.currentSprite.blendMode = slot.blendMode;\r\n        }\r\n        else if (type === spine.AttachmentType.skinnedmesh || type === spine.AttachmentType.mesh || type === spine.AttachmentType.linkedmesh)\r\n        {\r\n            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name)\r\n            {\r\n                var meshName = attachment.name;\r\n                if (slot.currentMesh !== undefined)\r\n                {\r\n                    slot.currentMesh.visible = false;\r\n                }\r\n\r\n                slot.meshes = slot.meshes || {};\r\n\r\n                if (slot.meshes[meshName] !== undefined)\r\n                {\r\n                    slot.meshes[meshName].visible = true;\r\n                }\r\n                else\r\n                {\r\n                    var mesh = this.createMesh(slot, attachment);\r\n                    slotContainer.addChild(mesh);\r\n                }\r\n\r\n                slot.currentMesh = slot.meshes[meshName];\r\n                slot.currentMeshName = meshName;\r\n            }\r\n            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);\r\n            if (PIXI.VERSION[0] !== '3') {\r\n                // PIXI version 4\r\n                slot.currentMesh.dirty = true;\r\n                //only for PIXI v4\r\n                var tintRgb = slot.currentMesh.tintRgb;\r\n                tintRgb[0] = r0 * slot.r * attachment.r;\r\n                tintRgb[1] = g0 * slot.g * attachment.g;\r\n                tintRgb[2] = b0 * slot.b * attachment.b;\r\n            }\r\n            slot.currentMesh.blendMode = slot.blendMode;\r\n        }\r\n        else\r\n        {\r\n            slotContainer.visible = false;\r\n            continue;\r\n        }\r\n        slotContainer.visible = true;\r\n\r\n        slotContainer.alpha = slot.a;\r\n    }\r\n};\r\n\r\n/**\r\n * When autoupdate is set to yes this function is used as pixi's updateTransform function\r\n *\r\n * @private\r\n */\r\nSpine.prototype.autoUpdateTransform = function ()\r\n{\r\n    if (Spine.globalAutoUpdate) {\r\n        this.lastTime = this.lastTime || Date.now();\r\n        var timeDelta = (Date.now() - this.lastTime) * 0.001;\r\n        this.lastTime = Date.now();\r\n        this.update(timeDelta);\r\n    } else {\r\n        this.lastTime = 0;\r\n    }\r\n\r\n    PIXI.Container.prototype.updateTransform.call(this);\r\n};\r\n\r\n/**\r\n * Create a new sprite to be used with spine.RegionAttachment\r\n *\r\n * @param slot {spine.Slot} The slot to which the attachment is parented\r\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n * @private\r\n */\r\nSpine.prototype.createSprite = function (slot, attachment)\r\n{\r\n    var descriptor = attachment.rendererObject;\r\n    var texture = descriptor.texture;\r\n    var sprite = new PIXI.Sprite(texture);\r\n    sprite.scale.x = attachment.scaleX * attachment.width / descriptor.originalWidth;\r\n    sprite.scale.y = - attachment.scaleY * attachment.height / descriptor.originalHeight;\r\n    sprite.rotation = attachment.rotation * spine.degRad;\r\n    sprite.anchor.x = 0.5;\r\n    sprite.anchor.y = 0.5;\r\n    sprite.position.x = attachment.x;\r\n    sprite.position.y = attachment.y;\r\n    sprite.alpha = attachment.a;\r\n\r\n    slot.sprites = slot.sprites || {};\r\n    slot.sprites[descriptor.name] = sprite;\r\n    return sprite;\r\n};\r\n\r\n/**\r\n * Creates a Strip from the spine data\r\n * @param slot {spine.Slot} The slot to which the attachment is parented\r\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\r\n * @private\r\n */\r\nSpine.prototype.createMesh = function (slot, attachment)\r\n{\r\n    var descriptor = attachment.rendererObject;\r\n    var baseTexture = descriptor.page.rendererObject;\r\n    var texture = new PIXI.Texture(baseTexture);\r\n\r\n    var strip = new PIXI.mesh.Mesh(\r\n        texture,\r\n        new Float32Array(attachment.uvs.length),\r\n        new Float32Array(attachment.uvs),\r\n        new Uint16Array(attachment.triangles),\r\n        PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\r\n\r\n    strip.canvasPadding = 1.5;\r\n\r\n    strip.alpha = attachment.a;\r\n\r\n    slot.meshes = slot.meshes || {};\r\n    slot.meshes[attachment.name] = strip;\r\n\r\n    return strip;\r\n};\r\n\r\n/**\r\n * Changes texture in attachment in specific slot.\r\n *\r\n * PIXI runtime feature, it was made to satisfy our users.\r\n *\r\n * @param slotName {string}\r\n * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n * @returns {boolean} Success flag\r\n */\r\nSpine.prototype.hackTextureBySlotIndex = function(slotIndex, texture, size) {\r\n    var slot = this.skeleton.slots[slotIndex];\r\n    if (!slot) {\r\n        return false;\r\n    }\r\n    var attachment = slot.attachment;\r\n    if (!attachment || !attachment.hackRegion) {\r\n        return false;\r\n    }\r\n    var region = null;\r\n    if (texture) {\r\n        region = new spine.AtlasRegion();\r\n        region.texture = texture;\r\n        region.size = size;\r\n    }\r\n\r\n    attachment.hackRegion(region);\r\n    var descriptor = attachment.rendererObject;\r\n    if (slot.currentSprite) {\r\n        var sprite = slot.currentSprite;\r\n        sprite.texture = descriptor.texture;\r\n        sprite.scale.x = attachment.width / descriptor.originalWidth;\r\n        sprite.scale.y = - attachment.height / descriptor.originalHeight;\r\n    }\r\n    if (slot.currentMesh) {\r\n        var mesh = slot.currentMesh;\r\n        mesh.texture = descriptor.texture;\r\n        for (var i = 0; i < attachment.uvs.length; i++) {\r\n            mesh.uvs[i] = attachment.uvs[i];\r\n        }\r\n        if (PIXI.VERSION[0] !== '3') {\r\n            // PIXI version 4\r\n            mesh.indexDirty = true;\r\n        } else {\r\n            // PIXI version 3\r\n            mesh.dirty = true;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\n/**\r\n * Changes texture in attachment in specific slot.\r\n *\r\n * PIXI runtime feature, it was made to satisfy our users.\r\n *\r\n * @param slotName {string}\r\n * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\r\n * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\r\n * @returns {boolean} Success flag\r\n */\r\nSpine.prototype.hackTextureBySlotName = function(slotName, texture, size) {\r\n    var index = this.skeleton.findSlotIndex(slotName);\r\n    if (index == -1) {\r\n        return false;\r\n    }\r\n    return this.hackTextureBySlotIndex(index,texture, size);\r\n};\r\n\r\nfunction SlotContainerUpdateTransformV3()\r\n{\r\n    var pt = this.parent.worldTransform;\r\n    var wt = this.worldTransform;\r\n    var lt = this.localTransform;\r\n    wt.a  = lt.a  * pt.a + lt.b  * pt.c;\r\n    wt.b  = lt.a  * pt.b + lt.b  * pt.d;\r\n    wt.c  = lt.c  * pt.a + lt.d  * pt.c;\r\n    wt.d  = lt.c  * pt.b + lt.d  * pt.d;\r\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\r\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\r\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\r\n    this._currentBounds = null;\r\n};\r\n","/**\r\n * @file        Spine resource loader\r\n * @author      Ivan Popelyshev <ivan.popelyshev@gmail.com>\r\n * @copyright   2013-2015 GoodBoyDigital\r\n * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}\r\n */\r\n\r\n/**\r\n * @namespace PIXI.loaders\r\n */\r\n\r\nvar atlasParser = require('./atlasParser');\r\n\r\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\r\nPIXI.loader.use(atlasParser());\r\n","var Resource = PIXI.loaders.Resource,\r\n    spine = require('../SpineRuntime'),\r\n    imageLoaderAdapter = require('./imageLoaderAdapter');\r\n\r\nvar atlasParser = module.exports = function () {\r\n    return function (resource, next) {\r\n        // skip if no data, its not json, or it isn't atlas data\r\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\r\n            return next();\r\n        }\r\n\r\n        var metadataAtlas = resource.metadata ? resource.metadata.spineAtlas: null;\r\n        if (metadataAtlas === false) {\r\n            return next();\r\n        }\r\n        if (metadataAtlas && metadataAtlas.pages) {\r\n            //its an atlas!\r\n            var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(metadataAtlas));\r\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n            resource.spineData = skeletonData;\r\n            resource.spineAtlas = metadataAtlas;\r\n            if (atlasParser.enableCaching) {\r\n                atlasParser.AnimCache[resource.name] = resource.spineData;\r\n            }\r\n\r\n            return next();\r\n        }\r\n\r\n        var metadataAtlasSuffix = '.atlas';\r\n        if (resource.metadata && resource.metadata.spineAtlasSuffix) {\r\n            metadataAtlasSuffix = resource.metadata.spineAtlasSuffix;\r\n        }\r\n\r\n        /**\r\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\r\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\r\n         * have the same name\r\n         */\r\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + metadataAtlasSuffix;\r\n        //remove the baseUrl\r\n        atlasPath = atlasPath.replace(this.baseUrl, '');\r\n\r\n        var atlasOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            xhrType: Resource.XHR_RESPONSE_TYPE.TEXT,\r\n            metadata: resource.metadata ? resource.metadata.spineMetadata : null\r\n        };\r\n        var imageOptions = {\r\n            crossOrigin: resource.crossOrigin,\r\n            metadata: resource.metadata ? resource.metadata.imageMetadata: null\r\n        };\r\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\r\n        //remove the baseUrl\r\n        baseUrl = baseUrl.replace(this.baseUrl, '');\r\n\r\n        var adapter = imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\r\n\r\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (res) {\r\n            new spine.Atlas(this.xhr.responseText, adapter, function(spineAtlas) {\r\n                var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(spineAtlas));\r\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\r\n\r\n                resource.spineData = skeletonData;\r\n                resource.spineAtlas = spineAtlas;\r\n                if (atlasParser.enableCaching) {\r\n                    atlasParser.AnimCache[resource.name] = resource.spineData;\r\n                }\r\n\r\n                next();\r\n            });\r\n        });\r\n    };\r\n};\r\n\r\natlasParser.AnimCache = {};\r\natlasParser.enableCaching = false;\r\n","var spine = require('../SpineRuntime');\r\n\r\nmodule.exports = function (loader, namePrefix, baseUrl, imageOptions) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line, callback) {\r\n        var name = namePrefix + line;\r\n        var url = baseUrl + line;\r\n        loader.add(name, url, imageOptions, function(resource) {\r\n            callback(resource.texture.baseTexture);\r\n        });\r\n    }\r\n};\r\n","module.exports = {\r\n    atlasParser: require('./atlasParser'),\r\n    Loader: require('./Loader'),\r\n    syncImageLoaderAdapter: require('./syncImageLoaderAdapter'),\r\n    imageLoaderAdapter: require('./imageLoaderAdapter')\r\n};\r\n","var spine = require('../SpineRuntime');\r\n\r\nmodule.exports = function (baseUrl, crossOrigin) {\r\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\r\n    {\r\n        baseUrl += '/';\r\n    }\r\n    return function(line, callback) {\r\n        callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\r\n    }\r\n};\r\n"],"sourceRoot":"./"}